{************************************************************************}
{                                                                        }
{       Borland Delphi Runtime Library                                   }
{       Pkcs11 interface unit                                             }
{                                                                        }
{ Portions created by Microsoft are                                      }
{ Copyright (C) 1995-1999 Microsoft Corporation.                         }
{ All Rights Reserved.                                                   }
{                                                                        }
{ Portions created by RSA Inc are                                        }
{ Copyright RSA Security Inc. PKCS #11 Cryptographic Token Interface     }
{                                                                        }
{ The original file is: pkcs11f.h, version 1.1.                          }
{ The original Pascal code is: pkcs11f.pas, released 18 May 2006.        }
{ The initial developer of the Pascal code is Danny Heijl                }
{ (danny.heijl@telenet.be).                                              }
{                                                                        }
{ Portions created by Danny Heijl are                                    }
{ Copyright (C) 2006 Danny Heijl.                                        }
{                                                                        }
{ Contributor(s): Danny Heijl                                            }
{                                                                        }
{       Obtained through:                                                }
{                                                                        }
{       Joint Endeavour of Delphi Innovators (Project JEDI)              }
{                                                                        }
{ You may retrieve the latest version of this file at the Project        }
{ JEDI home page, located at http://delphi-jedi.org                      }
{                                                                        }
{ The contents of this file are used with permission, subject to         }
{ the Mozilla Public License Version 1.1 (the "License"); you may        }
{ not use this file except in compliance with the License. You may       }
{ obtain a copy of the License at                                        }
{ http://www.mozilla.org/MPL/MPL-1.1.html                                }
{                                                                        }
{ Software distributed under the License is distributed on an            }
{ "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or         }
{ implied. See the License for the specific language governing           }
{ rights and limitations under the License.                              }
{                                                                        }
{************************************************************************}

{-------------------------------------------------------------------------------
   $Id: pkcs11t.pas,v 1.3 2006/08/09 08:39:31 DH Exp $
   Unit Name: pkcs11t
   Author:    Danny Heijl
   Date:      04-08-2006
   Created:   17-06-2003
   Purpose:   manual translation of the RSA Security Inc pkcs11t.h from C to Pascal
   History:
     - Original: DH, 17-06-2003
     - sync with PKCS11 V2.20: DH, 09-08-2006

   Original license: see RSA Security Inc license below

-------------------------------------------------------------------------------}
unit PKCS11T;
{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 2000 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      Final Delphi-Jedi (Darth) command-line units edition                }
{                                                                          }
{    Generated Date: 17-06-2003                                            }
{    Generated Time: 13:43:58                                              }
{                                                                          }
{**************************************************************************}

interface

uses
  Windows;

{=> PKCS11T.H <=}

{ /* pkcs11t.h include file for PKCS #11.*/ }
{+// $Revision: 1.3 $*/ }

{+// License to copy and use this software is granted provided that it is }
{* identified as "RSA Security Inc. PKCS #11 Cryptographic Token Interface }
{-* (Cryptoki)" in all material mentioning or referencing this software. }

{-* License is also granted to make and use derivative works provided that }
{* such works are identified as "derived from the RSA Security Inc. PKCS #11 }
{-* Cryptographic Token Interface (Cryptoki)" in all material mentioning or }
{-* referencing the derived work. }

{-* RSA Security Inc. makes no representations concerning either the }
{-* merchantability of this software or the suitability of this software for }
{-* any particular purpose. It is provided "as is" without express or implied }
{-* warranty of any kind. }
{= }

{+// See top of pkcs11.h for information about the macros that }
{-* must be defined and the structure-packing conventions that }
{=* must be set before including this file. }

{$IFNDEF _PKCS11T_H_}
{$DEFINE _PKCS11T_H_}

{$DEFINE CK_DISABLE_TRUE_FALSE}

{$IFNDEF CK_DISABLE_TRUE_FALSE}
{$IFNDEF FALSE}
const
  FALSE = 0;
{$ENDIF}

{$IFNDEF TRUE}
const
  TRUE = (not FALSE);
{$ENDIF}
{$ENDIF}

const
  CK_TRUE = 1;
  CK_FALSE = 0;

  {+// an unsigned 8-bit value*/ }
type
  CK_BYTE = Byte;

  {+// an unsigned 8-bit character*/ }
  CK_CHAR = CK_BYTE;

  {+// an 8-bit UTF-8 character*/ }
  CK_UTF8CHAR = CK_BYTE;

  {+// a BYTE-sized Boolean flag*/ }
  CK_BBOOL = CK_BYTE;

  {+// an unsigned value, at least 32 bits long*/ }
  CK_ULONG = Cardinal;

  {+// a signed value, the same size as a CK_ULONG*/ }
  {+// CK_LONG is new for v2.0*/ }
  CK_LONG = LongInt;

  {+// at least 32 bits; each bit is a Boolean flag*/ }
  CK_FLAGS = CK_ULONG;

  {+// some special values for certain CK_ULONG variables*/ }
const
  CK_UNAVAILABLE_INFORMATION = ($FFFFFFFF);
  CK_EFFECTIVELY_INFINITE = 0;

type
  CK_BYTE_PTR = ^CK_BYTE;
  CK_CHAR_PTR = ^CK_CHAR;
  CK_UTF8CHAR_PTR = ^CK_UTF8CHAR;
  CK_ULONG_PTR = ^CK_ULONG;
  CK_VOID_PTR = Pointer;

  {+// Pointer to a CK_VOID_PTR-- i.e., pointer to pointer to void*/ }
  CK_VOID_PTR_PTR = ^Pointer;

  {+// The following value is always invalid if used as a session*/ }
  {+// handle or object handle*/ }
const
  CK_INVALID_HANDLE = 0;

type
  CK_VERSION = packed record
    major: CK_BYTE;                     {= integer portion of version number }
    minor: CK_BYTE;                     {= 1/100ths portion of version number }
  end {CK_VERSION};

  CK_VERSION_PTR = ^CK_VERSION;

  CK_INFO = packed record {+// manufacturerID and libraryDecription have been changed from }
    {=* CK_CHAR to CK_UTF8CHAR for v2.10 }
    cryptokiVersion: CK_VERSION;        {= Cryptoki interface ver }
    manufacturerID: array[0..32 - 1] of CK_UTF8CHAR; {= blank padded }
    flags: CK_FLAGS;                    {= must be zero }
    {+// libraryDescription and libraryVersion are new for v2.0*/ }
    libraryDescription: array[0..32 - 1] of CK_UTF8CHAR; {= blank padded }
    libraryVersion: CK_VERSION;         {= version of library }
  end {CK_INFO};
  CK_INFO_PTR = ^CK_INFO;

  {+// CK_NOTIFICATION enumerates the types of notifications that }
  {=* Cryptoki provides to an application }
  {+// CK_NOTIFICATION has been changed from an enum to a CK_ULONG }
  {=* for v2.0 }
type
  CK_NOTIFICATION = CK_ULONG;

const
  CKN_SURRENDER = 0;

type
  CK_SLOT_ID = CK_ULONG;
  CK_SLOT_ID_PTR = ^CK_SLOT_ID;

  {+// CK_SLOT_INFO provides information about a slot*/ }
  CK_SLOT_INFO = packed record {+// slotDescription and manufacturerID have been changed from }
    {=* CK_CHAR to CK_UTF8CHAR for v2.10 }
    slotDescription: array[0..64 - 1] of CK_UTF8CHAR; {= blank padded }
    manufacturerID: array[0..32 - 1] of CK_UTF8CHAR; {= blank padded }
    flags: CK_FLAGS; {+// hardwareVersion and firmwareVersion are new for v2.0*/ }
    hardwareVersion: CK_VERSION;        {= version of hardware }
    firmwareVersion: CK_VERSION;        {= version of firmware }
  end {CK_SLOT_INFO};

  {+// flags: bit flags that provide capabilities of the slot }
  {-* Bit Flag Mask Meaning }
  {= }
const
  CKF_TOKEN_PRESENT = $00000001;        {/* a token is there*/}
  CKF_REMOVABLE_DEVICE = $00000002;     {/* removable devices*/}
  CKF_HW_SLOT = $00000004;        {/* hardware slot*/}

type
  CK_SLOT_INFO_PTR = ^CK_SLOT_INFO;

  {+// CK_TOKEN_INFO provides information about a token*/ }
  CK_TOKEN_INFO = packed record {+// label, manufacturerID, and model have been changed from }
    {=* CK_CHAR to CK_UTF8CHAR for v2.10 }
    _label: array[0..32 - 1] of CK_UTF8CHAR; {= blank padded }
    manufacturerID: array[0..32 - 1] of CK_UTF8CHAR; {= blank padded }
    model: array[0..16 - 1] of CK_UTF8CHAR; {= blank padded }
    serialNumber: array[0..16 - 1] of CK_CHAR; {= blank padded }
    flags: CK_FLAGS;                    {= see below }
    {+// ulMaxSessionCount, ulSessionCount, ulMaxRwSessionCount, }
    {-* ulRwSessionCount, ulMaxPinLen, and ulMinPinLen have all been }
    {=* changed from CK_USHORT to CK_ULONG for v2.0 }
    ulMaxSessionCount: CK_ULONG;        {= max open sessions }
    ulSessionCount: CK_ULONG;           {= sess. now open }
    ulMaxRwSessionCount: CK_ULONG;      {= max R/W sessions }
    ulRwSessionCount: CK_ULONG;         {= R/W sess. now open }
    ulMaxPinLen: CK_ULONG;              {= in bytes }
    ulMinPinLen: CK_ULONG;              {= in bytes }
    ulTotalPublicMemory: CK_ULONG;      {= in bytes }
    ulFreePublicMemory: CK_ULONG;       {= in bytes }
    ulTotalPrivateMemory: CK_ULONG;     {= in bytes }
    ulFreePrivateMemory: CK_ULONG;      {= in bytes }

    {+// hardwareVersion, firmwareVersion, and time are new for }
    {=* v2.0 }
    hardwareVersion: CK_VERSION;        {= version of hardware }
    firmwareVersion: CK_VERSION;        {= version of firmware }
    utcTime: array[0..16 - 1] of CK_CHAR; {= time }
  end {CK_TOKEN_INFO};

  {+// The flags parameter is defined as follows: }
  {-* Bit Flag Mask Meaning }
  {= }
const
  CKF_RNG = $00000001;        {/* has random #}

  {+// CKF_RESTORE_KEY_NOT_NEEDED is new for v2.0. If it is set, }
  {-* that means that*every* time the state of cryptographic }
  {-* operations of a session is successfully saved, all keys }
  {=* needed to continue those operations are stored in the state }
  CKF_RESTORE_KEY_NOT_NEEDED = $00000020;

  {+// CKF_CLOCK_ON_TOKEN is new for v2.0. If it is set, that means }
  {-* that the token has some sort of clock. The time on that }
  {=* clock is returned in the token info structure }
  CKF_CLOCK_ON_TOKEN = $00000040;

  {+// CKF_PROTECTED_AUTHENTICATION_PATH is new for v2.0. If it is }
  {-* set, that means that there is some way for the user to login }
  {=* without sending a PIN through the Cryptoki library itself }
  CKF_PROTECTED_AUTHENTICATION_PATH = $00000100;

  {+// CKF_DUAL_CRYPTO_OPERATIONS is new for v2.0. If it is true, }
  {-* that means that a single session with the token can perform }
  {-* dual simultaneous cryptographic operations (digest and }
  {-* encrypt; decrypt and digest; sign and encrypt; and decrypt }
  {=* and sign) }
  CKF_DUAL_CRYPTO_OPERATIONS = $00000200;

  {+// CKF_TOKEN_INITIALIZED if new for v2.10. If it is true, the }
  {-* token has been initialized using C_InitializeToken or an }
  {* equivalent mechanism outside the scope of PKCS #11. }
  {-* Calling C_InitializeToken when this flag is set will cause }
  {=* the token to be reinitialized. }
  CKF_TOKEN_INITIALIZED = $00000400;

  {+// CKF_SECONDARY_AUTHENTICATION if new for v2.10. If it is }
  {-* true, the token supports secondary authentication for }
  {=* private key objects. }
  CKF_SECONDARY_AUTHENTICATION = $00000800;

  {+// CKF_USER_PIN_COUNT_LOW if new for v2.10. If it is true, an }
  {-* incorrect user login PIN has been entered at least once }
  {=* since the last successful authentication. }
  CKF_USER_PIN_COUNT_LOW = $00010000;

  {+// CKF_USER_PIN_FINAL_TRY if new for v2.10. If it is true, }
  {=* supplying an incorrect user PIN will it to become locked. }
  CKF_USER_PIN_FINAL_TRY = $00020000;

  {+// CKF_USER_PIN_LOCKED if new for v2.10. If it is true, the }
  {-* user PIN has been locked. User login to the token is not }
  {=* possible. }
  CKF_USER_PIN_LOCKED = $00040000;

  {+// CKF_USER_PIN_TO_BE_CHANGED if new for v2.10. If it is true, }
  {-* the user PIN value is the default value set by token }
  {-* initialization or manufacturing, or the PIN has been }
  {=* expired by the card. }
  CKF_USER_PIN_TO_BE_CHANGED = $00080000;

  {+// CKF_SO_PIN_COUNT_LOW if new for v2.10. If it is true, an }
  {-* incorrect SO login PIN has been entered at least once since }
  {=* the last successful authentication. }
  CKF_SO_PIN_COUNT_LOW = $00100000;

  {+// CKF_SO_PIN_FINAL_TRY if new for v2.10. If it is true, }
  {=* supplying an incorrect SO PIN will it to become locked. }
  CKF_SO_PIN_FINAL_TRY = $00200000;

  {+// CKF_SO_PIN_LOCKED if new for v2.10. If it is true, the SO }
  {-* PIN has been locked. SO login to the token is not possible. }
  {= }
  CKF_SO_PIN_LOCKED = $00400000;

  {+// CKF_SO_PIN_TO_BE_CHANGED if new for v2.10. If it is true, }
  {-* the SO PIN value is the default value set by token }
  {-* initialization or manufacturing, or the PIN has been }
  {=* expired by the card. }
  CKF_SO_PIN_TO_BE_CHANGED = $00800000;

type
  CK_TOKEN_INFO_PTR = ^CK_TOKEN_INFO;

  {+// CK_SESSION_HANDLE is a Cryptoki-assigned value that }
  {=* identifies a session }
  CK_SESSION_HANDLE = CK_ULONG;

  CK_SESSION_HANDLE_PTR = ^CK_SESSION_HANDLE;

  {+// CK_USER_TYPE enumerates the types of Cryptoki users*/ }
  {+// CK_USER_TYPE has been changed from an enum to a CK_ULONG for }
  {=* v2.0 }
  CK_USER_TYPE = CK_ULONG;

const
  CKU_SO = 0;                  {+// Security Officer*/ }
  CKU_USER = 1;                {+// Normal user*/ }
  CKU_CONTEXT_SPECIFIC = 2;    {+// Context specific (added in v2.20) */ }

  {+// CK_STATE enumerates the session states*/ }
  {+// CK_STATE has been changed from an enum to a CK_ULONG for }
  {=* v2.0 }
type
  CK_STATE = CK_ULONG;

const
  CKS_RO_PUBLIC_SESSION = 0;
  CKS_RO_USER_FUNCTIONS = 1;
  CKS_RW_PUBLIC_SESSION = 2;
  CKS_RW_USER_FUNCTIONS = 3;
  CKS_RW_SO_FUNCTIONS = 4;

  {+// CK_SESSION_INFO provides information about a session*/ }
type
  CK_SESSION_INFO = record
    slotID: CK_SLOT_ID;
    state: CK_STATE;
    flags: CK_FLAGS;                    {= see below }
    {+// ulDeviceError was changed from CK_USHORT to CK_ULONG for }
    {=* v2.0 }
    ulDeviceError: CK_ULONG;            {= device-dependent error code }
  end {CK_SESSION_INFO};

  {+// The flags are defined in the following table: }
  {-* Bit Flag Mask Meaning }
  {= }
const
  CKF_RW_SESSION = $00000002;        {/* session is r/w*/}
  CKF_SERIAL_SESSION = $00000004;       {/* no parallel*/}

type
  CK_SESSION_INFO_PTR = ^CK_SESSION_INFO;

  {+// CK_OBJECT_HANDLE is a token-specific identifier for an }
  {=* object }
  CK_OBJECT_HANDLE = CK_ULONG;

  CK_OBJECT_HANDLE_PTR = ^CK_OBJECT_HANDLE;

  {+// CK_OBJECT_CLASS is a value that identifies the classes (or }
  {-* types) of objects that Cryptoki recognizes. It is defined }
  {=* as follows: }
  {+// CK_OBJECT_CLASS was changed from CK_USHORT to CK_ULONG for }
  {=* v2.0 }
  CK_OBJECT_CLASS = CK_ULONG;

  {+// The following classes of objects are defined:*/ }
  {+// CKO_HW_FEATURE is new for v2.10*/ }
  {+// CKO_DOMAIN_PARAMETERS is new for v2.11*/ }
  {+// CKO_MECHANISM is new for v2.20 */ }
const
  CKO_DATA = $00000000;
  CKO_CERTIFICATE = $00000001;
  CKO_PUBLIC_KEY = $00000002;
  CKO_PRIVATE_KEY = $00000003;
  CKO_SECRET_KEY = $00000004;
  CKO_HW_FEATURE = $00000005;
  CKO_DOMAIN_PARAMETERS = $00000006;
  CKO_VENDOR_DEFINED = $80000000;

type
  CK_OBJECT_CLASS_PTR = ^CK_OBJECT_CLASS;

  {+// CK_HW_FEATURE_TYPE is new for v2.10. CK_HW_FEATURE_TYPE is a }
  {-* value that identifies the hardware feature type of an object }
  {=* with CK_OBJECT_CLASS equal to CKO_HW_FEATURE. }
  CK_HW_FEATURE_TYPE = CK_ULONG;

  {+// The following hardware feature types are defined */ }
  {+// CKH_USER_INTERFACE is new for v2.20 */ }
const
  CKH_MONOTONIC_COUNTER = $00000001;
  CKH_CLOCK = $00000002;
  CKH_USER_INTERFACE = $00000003;
  CKH_VENDOR_DEFINED = $80000000;

  {+// CK_KEY_TYPE is a value that identifies a key type*/ }
  {+// CK_KEY_TYPE was changed from CK_USHORT to CK_ULONG for v2.0*/ }
type
  CK_KEY_TYPE = CK_ULONG;

  {+// the following key types are defined:*/ }
const
  CKK_RSA = $00000000;
  CKK_DSA = $00000001;
  CKK_DH = $00000002;

  {+// CKK_ECDSA and CKK_KEA are new for v2.0*/ }
  {+// CKK_ECDSA is deprecated in v2.11, CKK_EC is preferred.*/ }
  CKK_ECDSA = $00000003;
  CKK_EC = $00000003;
  CKK_X9_42_DH = $00000004;
  CKK_KEA = $00000005;

  CKK_GENERIC_SECRET = $00000010;
  CKK_RC2 = $00000011;
  CKK_RC4 = $00000012;
  CKK_DES = $00000013;
  CKK_DES2 = $00000014;
  CKK_DES3 = $00000015;

  {+// all these key types are new for v2.0*/ }
  CKK_CAST = $00000016;
  CKK_CAST3 = $00000017;
  {+// CKK_CAST5 is deprecated in v2.11, CKK_CAST128 is preferred.*/ }
  CKK_CAST5 = $00000018;
  CKK_CAST128 = $00000018;
  CKK_RC5 = $00000019;
  CKK_IDEA = $0000001A;
  CKK_SKIPJACK = $0000001B;
  CKK_BATON = $0000001C;
  CKK_JUNIPER = $0000001D;
  CKK_CDMF = $0000001E;
  CKK_AES = $0000001;

  {+// BlowFish and TwoFish are new for v2.20 */ }
  CKK_BLOWFISH = $00000020;
  CKK_TWOFISH = $00000021;
  CKK_VENDOR_DEFINED = $80000000;

  {+// CK_CERTIFICATE_TYPE is a value that identifies a certificate }
  {=* type }
  {+// CK_CERTIFICATE_TYPE was changed from CK_USHORT to CK_ULONG }
  {=* for v2.0 }
type
  CK_CERTIFICATE_TYPE = CK_ULONG;

  {+// The following certificate types are defined:*/ }
  {+// CKC_X_509_ATTR_CERT is new for v2.10*/ }
  {+// CKC_WTLS is new for v2.20 */ }
const
  CKC_X_509 = $00000000;
  CKC_X_509_ATTR_CERT = $00000001;
  CKC_WTLS = $00000002;
  CKC_VENDOR_DEFINED = $80000000;

  {+// CK_ATTRIBUTE_TYPE is a value that identifies an attribute }
  {=* type }
  {+// CK_ATTRIBUTE_TYPE was chCK_RSA_PKCS_MGF_TYPEanged from CK_USHORT to CK_ULONG for }
  {=* v2.0 }
type
  CK_ATTRIBUTE_TYPE = CK_ULONG;
  {+// The CKF_ARRAY_ATTRIBUTE flag identifies an attribute which
       consists of an array of values. */ }
const
  CKF_ARRAY_ATTRIBUTE = $40000000;
  {+// The following attribute types are defined:*/ }
  CKA_CLASS = $00000000;
  CKA_TOKEN = $00000001;
  CKA_PRIVATE = $00000002;
  CKA_LABEL = $00000003;
  CKA_APPLICATION = $00000010;
  CKA_VALUE = $00000011;
  {+// CKA_OBJECT_ID is new for v2.10*/ }
  CKA_OBJECT_ID = $00000012;
  CKA_CERTIFICATE_TYPE = $00000080;
  CKA_ISSUER = $00000081;
  CKA_SERIAL_NUMBER = $00000082;
  {+// CKA_AC_ISSUER, CKA_OWNER, and CKA_ATTR_TYPES are new }
  {=* for v2.10 }
  CKA_AC_ISSUER = $00000083;
  CKA_OWNER = $00000084;
  CKA_ATTR_TYPES = $00000085;
  {+// CKA_TRUSTED is new for v2.11*/ }
  CKA_TRUSTED = $00000086;
  {+// CKA_CERTIFICATE_CATEGORY ... CKA_CHECK_VALUE are new for v2.20 */ }
  CKA_CERTIFICATE_CATEGORY = $00000087;
  CKA_JAVA_MIDP_SECURITY_DOMAIN = $00000088;
  CKA_URL = $00000089;
  CKA_HASH_OF_SUBJECT_PUBLIC_KEY = $0000008A;
  CKA_HASH_OF_ISSUER_PUBLIC_KEY = $0000008B;
  CKA_CHECK_VALUE = $00000090;
  CKA_KEY_TYPE = $00000100;
  CKA_SUBJECT = $00000101;
  CKA_ID = $00000102;
  CKA_SENSITIVE = $00000103;
  CKA_ENCRYPT = $00000104;
  CKA_DECRYPT = $00000105;
  CKA_WRAP = $00000106;
  CKA_UNWRAP = $00000107;
  CKA_SIGN = $00000108;
  CKA_SIGN_RECOVER = $00000109;
  CKA_VERIFY = $0000010A;
  CKA_VERIFY_RECOVER = $0000010B;
  CKA_DERIVE = $0000010C;
  CKA_START_DATE = $00000110;
  CKA_END_DATE = $00000111;
  CKA_MODULUS = $00000120;
  CKA_MODULUS_BITS = $00000121;
  CKA_PUBLIC_EXPONENT = $00000122;
  CKA_PRIVATE_EXPONENT = $00000123;
  CKA_PRIME_1 = $00000124;
  CKA_PRIME_2 = $00000125;
  CKA_EXPONENT_1 = $00000126;
  CKA_EXPONENT_2 = $00000127;
  CKA_COEFFICIENT = $00000128;
  CKA_PRIME = $00000130;
  CKA_SUBPRIME = $00000131;
  CKA_BASE = $00000132;
  {+// CKA_PRIME_BITS and CKA_SUB_PRIME_BITS are new for v2.11*/ }
  CKA_PRIME_BITS = $00000133;
  CKA_SUBPRIME_BITS = $00000134;
  CKA_SUB_PRIME_BITS = CKA_SUBPRIME_BITS;
  {+// (To retain backwards-compatibility)*/ }
  CKA_VALUE_BITS = $00000160;
  CKA_VALUE_LEN = $00000161;
  {+// CKA_EXTRACTABLE, CKA_LOCAL, CKA_NEVER_EXTRACTABLE, }
  {-* CKA_ALWAYS_SENSITIVE, CKA_MODIFIABLE, CKA_ECDSA_PARAMS, }
  {=* and CKA_EC_POINT are new for v2.0 }
  CKA_EXTRACTABLE = $00000162;
  CKA_LOCAL = $00000163;
  CKA_NEVER_EXTRACTABLE = $00000164;
  CKA_ALWAYS_SENSITIVE = $00000165;
  {+// CKA_KEY_GEN_MECHANISM is new for v2.11*/ }
  CKA_KEY_GEN_MECHANISM = $00000166;
  CKA_MODIFIABLE = $00000170;
  {+// CKA_ECDSA_PARAMS is deprecated in v2.11, }
  {=* CKA_EC_PARAMS is preferred. }
  CKA_ECDSA_PARAMS = $00000180;
  CKA_EC_PARAMS = $00000180;
  CKA_EC_POINT = $00000181;
  {+// CKA_SECONDARY_AUTH, CKA_AUTH_PIN_FLAGS, }
  {-* CKA_HW_FEATURE_TYPE, CKA_RESET_ON_INIT, and CKA_HAS_RESET }
  {=* are new for v2.10. Deprecated in v2.11 and onwards. }
  CKA_SECONDARY_AUTH = $00000200;
  CKA_AUTH_PIN_FLAGS = $00000201;
  {+// CKA_ALWAYS_AUTHENTICATE ... CKA_UNWRAP_TEMPLATE are new for v2.20 */ }
  CKA_ALWAYS_AUTHENTICATE = $00000202;
  CKA_WRAP_WITH_TRUSTED = $00000210;
  CKA_WRAP_TEMPLATE = (CKF_ARRAY_ATTRIBUTE or $00000211);
  CKA_UNWRAP_TEMPLATE = (CKF_ARRAY_ATTRIBUTE or $00000212);

  CKA_HW_FEATURE_TYPE = $00000300;
  CKA_RESET_ON_INIT = $00000301;
  CKA_HAS_RESET = $00000302;

  {+//  The following attributes are new for v2.20 */ }
  CKA_PIXEL_X = $00000400;
  CKA_PIXEL_Y = $00000401;
  CKA_RESOLUTION = $00000402;
  CKA_CHAR_ROWS = $00000403;
  CKA_CHAR_COLUMNS = $00000404;
  CKA_COLOR = $00000405;
  CKA_BITS_PER_PIXEL = $00000406;
  CKA_CHAR_SETS = $00000480;
  CKA_ENCODING_METHODS = $00000481;
  CKA_MIME_TYPES = $00000482;
  CKA_MECHANISM_TYPE = $00000500;
  CKA_REQUIRED_CMS_ATTRIBUTES = $00000501;
  CKA_DEFAULT_CMS_ATTRIBUTES = $00000502;
  CKA_SUPPORTED_CMS_ATTRIBUTES = $00000503;
  CKA_ALLOWED_MECHANISMS = (CKF_ARRAY_ATTRIBUTE or $00000600);

  CKA_VENDOR_DEFINED = $80000000;

  {+// CK_ATTRIBUTE is a structure that includes the type, length }
  {=* and value of an attribute }
type
  CK_ATTRIBUTE = record
    _type: CK_ATTRIBUTE_TYPE;
    pValue: CK_VOID_PTR;
    {+// ulValueLen went from CK_USHORT to CK_ULONG for v2.0*/ }
    ulValueLen: CK_ULONG;               {= in bytes }
  end {CK_ATTRIBUTE};
  CK_ATTRIBUTE_PTR = ^CK_ATTRIBUTE;

  {+// CK_DATE is a structure that defines a date*/ }
  CK_DATE = record
    year: array[0..4 - 1] of CK_CHAR;   {= the year ("1900" - "9999") }
    month: array[0..2 - 1] of CK_CHAR;  {= the month ("01" - "12") }
    day: array[0..2 - 1] of CK_CHAR;    {= the day ("01" - "31") }
  end {CK_DATE};

  {+// CK_MECHANISM_TYPE is a value that identifies a mechanism type     }
  {+// CK_MECHANISM_TYPE was changed from CK_USHORT to CK_ULONG for v2.0 }
  CK_MECHANISM_TYPE = CK_ULONG;

  {+// the following mechanism types are defined:*/ }
const
  CKM_RSA_PKCS_KEY_PAIR_GEN = $00000000;
  CKM_RSA_PKCS = $00000001;
  CKM_RSA_9796 = $00000002;
  CKM_RSA_X_509 = $00000003;

  {+// CKM_MD2_RSA_PKCS, CKM_MD5_RSA_PKCS, and CKM_SHA1_RSA_PKCS }
  {=* are new for v2.0. They are mechanisms which hash and sign }
  CKM_MD2_RSA_PKCS = $00000004;
  CKM_MD5_RSA_PKCS = $00000005;
  CKM_SHA1_RSA_PKCS = $00000006;

  {+// CKM_RIPEMD128_RSA_PKCS, CKM_RIPEMD160_RSA_PKCS, and }
  {=* CKM_RSA_PKCS_OAEP are new for v2.10 }
  CKM_RIPEMD128_RSA_PKCS = $00000007;
  CKM_RIPEMD160_RSA_PKCS = $00000008;
  CKM_RSA_PKCS_OAEP = $00000009;

  {+// CKM_RSA_X9_31_KEY_PAIR_GEN, CKM_RSA_X9_31, CKM_SHA1_RSA_X9_31, }
  {=* CKM_RSA_PKCS_PSS, and CKM_SHA1_RSA_PKCS_PSS are new for v2.11 }
  CKM_RSA_X9_31_KEY_PAIR_GEN = $0000000A;
  CKM_RSA_X9_31 = $0000000B;
  CKM_SHA1_RSA_X9_31 = $0000000C;
  CKM_RSA_PKCS_PSS = $0000000D;
  CKM_SHA1_RSA_PKCS_PSS = $0000000E;

  CKM_DSA_KEY_PAIR_GEN = $00000010;
  CKM_DSA = $00000011;
  CKM_DSA_SHA1 = $00000012;
  CKM_DH_PKCS_KEY_PAIR_GEN = $00000020;
  CKM_DH_PKCS_DERIVE = $00000021;

  {+// CKM_X9_42_DH_KEY_PAIR_GEN, CKM_X9_42_DH_DERIVE, }
  {-* CKM_X9_42_DH_HYBRID_DERIVE, and CKM_X9_42_MQV_DERIVE are new for }
  {=* v2.11 }
  CKM_X9_42_DH_KEY_PAIR_GEN = $00000030;
  CKM_X9_42_DH_DERIVE = $00000031;
  CKM_X9_42_DH_HYBRID_DERIVE = $00000032;
  CKM_X9_42_MQV_DERIVE = $00000033;

  {+// CKM_SHA256/384/512 are new for v2.20 */ }
  CKM_SHA256_RSA_PKCS = $00000040;
  CKM_SHA384_RSA_PKCS = $00000041;
  CKM_SHA512_RSA_PKCS = $00000042;
  CKM_SHA256_RSA_PKCS_PSS = $00000043;
  CKM_SHA384_RSA_PKCS_PSS = $00000044;
  CKM_SHA512_RSA_PKCS_PSS = $00000045;

  CKM_RC2_KEY_GEN = $00000100;
  CKM_RC2_ECB = $00000101;
  CKM_RC2_CBC = $00000102;
  CKM_RC2_MAC = $00000103;

  {+// CKM_RC2_MAC_GENERAL and CKM_RC2_CBC_PAD are new for v2.0*/ }
  CKM_RC2_MAC_GENERAL = $00000104;
  CKM_RC2_CBC_PAD = $00000105;

  CKM_RC4_KEY_GEN = $00000110;
  CKM_RC4 = $00000111;
  CKM_DES_KEY_GEN = $00000120;
  CKM_DES_ECB = $00000121;
  CKM_DES_CBC = $00000122;
  CKM_DES_MAC = $00000123;

  {+// CKM_DES_MAC_GENERAL and CKM_DES_CBC_PAD are new for v2.0*/ }
  CKM_DES_MAC_GENERAL = $00000124;
  CKM_DES_CBC_PAD = $00000125;

  CKM_DES2_KEY_GEN = $00000130;
  CKM_DES3_KEY_GEN = $00000131;
  CKM_DES3_ECB = $00000132;
  CKM_DES3_CBC = $00000133;
  CKM_DES3_MAC = $00000134;

  {+// CKM_DES3_MAC_GENERAL, CKM_DES3_CBC_PAD, CKM_CDMF_KEY_GEN, }
  {-* CKM_CDMF_ECB, CKM_CDMF_CBC, CKM_CDMF_MAC, }
  {=* CKM_CDMF_MAC_GENERAL, and CKM_CDMF_CBC_PAD are new for v2.0 }
  CKM_DES3_MAC_GENERAL = $00000135;
  CKM_DES3_CBC_PAD = $00000136;
  CKM_CDMF_KEY_GEN = $00000140;
  CKM_CDMF_ECB = $00000141;
  CKM_CDMF_CBC = $00000142;
  CKM_CDMF_MAC = $00000143;
  CKM_CDMF_MAC_GENERAL = $00000144;
  CKM_CDMF_CBC_PAD = $00000145;

  {+// the following four DES mechanisms are new for v2.20 */ }
  CKM_DES_OFB64 = $00000150;
  CKM_DES_OFB8 = $00000151;
  CKM_DES_CFB64 = $00000152;
  CKM_DES_CFB8 = $00000153;

  CKM_MD2 = $00000200;

  {+// CKM_MD2_HMAC and CKM_MD2_HMAC_GENERAL are new for v2.0*/ }
  CKM_MD2_HMAC = $00000201;
  CKM_MD2_HMAC_GENERAL = $00000202;

  CKM_MD5 = $00000210;

  {+// CKM_MD5_HMAC and CKM_MD5_HMAC_GENERAL are new for v2.0*/ }
  CKM_MD5_HMAC = $00000211;
  CKM_MD5_HMAC_GENERAL = $00000212;

  CKM_SHA_1 = $00000220;

  {+// CKM_SHA_1_HMAC and CKM_SHA_1_HMAC_GENERAL are new for v2.0*/ }
  CKM_SHA_1_HMAC = $00000221;
  CKM_SHA_1_HMAC_GENERAL = $00000222;

  {+// CKM_RIPEMD128, CKM_RIPEMD128_HMAC, }
  {-* CKM_RIPEMD128_HMAC_GENERAL, CKM_RIPEMD160, CKM_RIPEMD160_HMAC, }
  {=* and CKM_RIPEMD160_HMAC_GENERAL are new for v2.10 }
  CKM_RIPEMD128 = $00000230;
  CKM_RIPEMD128_HMAC = $00000231;
  CKM_RIPEMD128_HMAC_GENERAL = $00000232;
  CKM_RIPEMD160 = $00000240;
  CKM_RIPEMD160_HMAC = $00000241;
  CKM_RIPEMD160_HMAC_GENERAL = $00000242;

  {+// CKM_SHA256/384/512 are new for v2.20 */ }
  CKM_SHA256 = $00000250;
  CKM_SHA256_HMAC = $00000251;
  CKM_SHA256_HMAC_GENERAL = $00000252;
  CKM_SHA384 = $00000260;
  CKM_SHA384_HMAC = $00000261;
  CKM_SHA384_HMAC_GENERAL = $00000262;
  CKM_SHA512 = $00000270;
  CKM_SHA512_HMAC = $00000271;
  CKM_SHA512_HMAC_GENERAL = $00000272;

  {+// All of the following mechanisms are new for v2.0*/ }
  {+// Note that CAST128 and CAST5 are the same algorithm*/ }
  CKM_CAST_KEY_GEN = $00000300;
  CKM_CAST_ECB = $00000301;
  CKM_CAST_CBC = $00000302;
  CKM_CAST_MAC = $00000303;
  CKM_CAST_MAC_GENERAL = $00000304;
  CKM_CAST_CBC_PAD = $00000305;
  CKM_CAST3_KEY_GEN = $00000310;
  CKM_CAST3_ECB = $00000311;
  CKM_CAST3_CBC = $00000312;
  CKM_CAST3_MAC = $00000313;
  CKM_CAST3_MAC_GENERAL = $00000314;
  CKM_CAST3_CBC_PAD = $00000315;
  CKM_CAST5_KEY_GEN = $00000320;
  CKM_CAST128_KEY_GEN = $00000320;
  CKM_CAST5_ECB = $00000321;
  CKM_CAST128_ECB = $00000321;
  CKM_CAST5_CBC = $00000322;
  CKM_CAST128_CBC = $00000322;
  CKM_CAST5_MAC = $00000323;
  CKM_CAST128_MAC = $00000323;
  CKM_CAST5_MAC_GENERAL = $00000324;
  CKM_CAST128_MAC_GENERAL = $00000324;
  CKM_CAST5_CBC_PAD = $00000325;
  CKM_CAST128_CBC_PAD = $00000325;
  CKM_RC5_KEY_GEN = $00000330;
  CKM_RC5_ECB = $00000331;
  CKM_RC5_CBC = $00000332;
  CKM_RC5_MAC = $00000333;
  CKM_RC5_MAC_GENERAL = $00000334;
  CKM_RC5_CBC_PAD = $00000335;
  CKM_IDEA_KEY_GEN = $00000340;
  CKM_IDEA_ECB = $00000341;
  CKM_IDEA_CBC = $00000342;
  CKM_IDEA_MAC = $00000343;
  CKM_IDEA_MAC_GENERAL = $00000344;
  CKM_IDEA_CBC_PAD = $00000345;
  CKM_GENERIC_SECRET_KEY_GEN = $00000350;
  CKM_CONCATENATE_BASE_AND_KEY = $00000360;
  CKM_CONCATENATE_BASE_AND_DATA = $00000362;
  CKM_CONCATENATE_DATA_AND_BASE = $00000363;
  CKM_XOR_BASE_AND_DATA = $00000364;
  CKM_EXTRACT_KEY_FROM_KEY = $00000365;
  CKM_SSL3_PRE_MASTER_KEY_GEN = $00000370;
  CKM_SSL3_MASTER_KEY_DERIVE = $00000371;
  CKM_SSL3_KEY_AND_MAC_DERIVE = $00000372;

  {+// CKM_SSL3_MASTER_KEY_DERIVE_DH, CKM_TLS_PRE_MASTER_KEY_GEN, }
  {-* CKM_TLS_MASTER_KEY_DERIVE, CKM_TLS_KEY_AND_MAC_DERIVE, and }
  {=* CKM_TLS_MASTER_KEY_DERIVE_DH are new for v2.11 }
  CKM_SSL3_MASTER_KEY_DERIVE_DH = $00000373;
  CKM_TLS_PRE_MASTER_KEY_GEN = $00000374;
  CKM_TLS_MASTER_KEY_DERIVE = $00000375;
  CKM_TLS_KEY_AND_MAC_DERIVE = $00000376;
  CKM_TLS_MASTER_KEY_DERIVE_DH = $00000377;

  {+// CKM_TLS_PRF is new for v2.20 */ }
  CKM_TLS_PRF = $00000378;

  CKM_SSL3_MD5_MAC = $00000380;
  CKM_SSL3_SHA1_MAC = $00000381;
  CKM_MD5_KEY_DERIVATION = $00000390;
  CKM_MD2_KEY_DERIVATION = $00000391;
  CKM_SHA1_KEY_DERIVATION = $00000392;

  {+// CKM_SHA256/384/512 are new for v2.20 */ }
  CKM_SHA256_KEY_DERIVATION = $00000393;
  CKM_SHA384_KEY_DERIVATION = $00000394;
  CKM_SHA512_KEY_DERIVATION = $00000395;

  CKM_PBE_MD2_DES_CBC = $000003A0;
  CKM_PBE_MD5_DES_CBC = $000003A1;
  CKM_PBE_MD5_CAST_CBC = $000003A2;
  CKM_PBE_MD5_CAST3_CBC = $000003A3;
  CKM_PBE_MD5_CAST5_CBC = $000003A4;
  CKM_PBE_MD5_CAST128_CBC = $000003A4;
  CKM_PBE_SHA1_CAST5_CBC = $000003A5;
  CKM_PBE_SHA1_CAST128_CBC = $000003A5;
  CKM_PBE_SHA1_RC4_128 = $000003A6;
  CKM_PBE_SHA1_RC4_40 = $000003A7;
  CKM_PBE_SHA1_DES3_EDE_CBC = $000003A8;
  CKM_PBE_SHA1_DES2_EDE_CBC = $000003A9;
  CKM_PBE_SHA1_RC2_128_CBC = $000003AA;
  CKM_PBE_SHA1_RC2_40_CBC = $000003AB;

  {+// CKM_PKCS5_PBKD2 is new for v2.10*/ }
  CKM_PKCS5_PBKD2 = $000003B0;

  CKM_PBA_SHA1_WITH_SHA1_HMAC = $000003C0;

  {+// WTLS mechanisms are new for v2.20 */ }
  CKM_WTLS_PRE_MASTER_KEY_GEN = $000003D0;
  CKM_WTLS_MASTER_KEY_DERIVE = $000003D1;
  CKM_WTLS_MASTER_KEY_DERIVE_DH_ECC = $000003D2;
  CKM_WTLS_PRF = $000003D3;
  CKM_WTLS_SERVER_KEY_AND_MAC_DERIVE = $000003D4;
  CKM_WTLS_CLIENT_KEY_AND_MAC_DERIVE = $000003D5;

  {+// CKM_CMS_SIG is new for v2.20 */ }
  CKM_CMS_SIG = $00000500;

  CKM_KEY_WRAP_LYNKS = $00000400;
  CKM_KEY_WRAP_SET_OAEP = $00000401;

  {+// Fortezza mechanisms*/ }
  CKM_SKIPJACK_KEY_GEN = $00001000;
  CKM_SKIPJACK_ECB64 = $00001001;
  CKM_SKIPJACK_CBC64 = $00001002;
  CKM_SKIPJACK_OFB64 = $00001003;
  CKM_SKIPJACK_CFB64 = $00001004;
  CKM_SKIPJACK_CFB32 = $00001005;
  CKM_SKIPJACK_CFB16 = $00001006;
  CKM_SKIPJACK_CFB8 = $00001007;
  CKM_SKIPJACK_WRAP = $00001008;
  CKM_SKIPJACK_PRIVATE_WRAP = $00001009;
  CKM_SKIPJACK_RELAYX = $0000100A;
  CKM_KEA_KEY_PAIR_GEN = $00001010;
  CKM_KEA_KEY_DERIVE = $00001011;
  CKM_FORTEZZA_TIMESTAMP = $00001020;
  CKM_BATON_KEY_GEN = $00001030;
  CKM_BATON_ECB128 = $00001031;
  CKM_BATON_ECB96 = $00001032;
  CKM_BATON_CBC128 = $00001033;
  CKM_BATON_COUNTER = $00001034;
  CKM_BATON_SHUFFLE = $00001035;
  CKM_BATON_WRAP = $00001036;

  {+// CKM_ECDSA_KEY_PAIR_GEN is deprecated in v2.11, }
  {=* CKM_EC_KEY_PAIR_GEN is preferred }
  CKM_ECDSA_KEY_PAIR_GEN = $00001040;
  CKM_EC_KEY_PAIR_GEN = $00001040;

  CKM_ECDSA = $00001041;
  CKM_ECDSA_SHA1 = $00001042;

  {+// CKM_ECDH1_DERIVE, CKM_ECDH1_COFACTOR_DERIVE, and CKM_ECMQV_DERIVE }
  {=* are new for v2.11 }
  CKM_ECDH1_DERIVE = $00001050;
  CKM_ECDH1_COFACTOR_DERIVE = $00001051;
  CKM_ECMQV_DERIVE = $00001052;

  CKM_JUNIPER_KEY_GEN = $00001060;
  CKM_JUNIPER_ECB128 = $00001061;
  CKM_JUNIPER_CBC128 = $00001062;
  CKM_JUNIPER_COUNTER = $00001063;
  CKM_JUNIPER_SHUFFLE = $00001064;
  CKM_JUNIPER_WRAP = $00001065;
  CKM_FASTHASH = $00001070;

  {+// CKM_AES_KEY_GEN, CKM_AES_ECB, CKM_AES_CBC, CKM_AES_MAC, }
  {-* CKM_AES_MAC_GENERAL, CKM_AES_CBC_PAD, CKM_DSA_PARAMETER_GEN, }
  {-* CKM_DH_PKCS_PARAMETER_GEN, and CKM_X9_42_DH_PARAMETER_GEN are }
  {=* new for v2.11 }
  CKM_AES_KEY_GEN = $00001080;
  CKM_AES_ECB = $00001081;
  CKM_AES_CBC = $00001082;
  CKM_AES_MAC = $00001083;
  CKM_AES_MAC_GENERAL = $00001084;
  CKM_AES_CBC_PAD = $00001085;

  {+// BlowFish and TwoFish are new for v2.20 */ }
  CKM_BLOWFISH_KEY_GEN = $00001090;
  CKM_BLOWFISH_CBC = $00001091;
  CKM_TWOFISH_KEY_GEN = $00001092;
  CKM_TWOFISH_CBC = $00001093;

   {+// CKM_xxx_ENCRYPT_DATA mechanisms are new for v2.20 */ }
  CKM_DES_ECB_ENCRYPT_DATA = $00001100;
  CKM_DES_CBC_ENCRYPT_DATA = $00001101;
  CKM_DES3_ECB_ENCRYPT_DATA = $00001102;
  CKM_DES3_CBC_ENCRYPT_DATA = $00001103;
  CKM_AES_ECB_ENCRYPT_DATA = $00001104;
  CKM_AES_CBC_ENCRYPT_DATA = $00001105;

  CKM_DSA_PARAMETER_GEN = $00002000;
  CKM_DH_PKCS_PARAMETER_GEN = $00002001;
  CKM_X9_42_DH_PARAMETER_GEN = $00002002;

  CKM_VENDOR_DEFINED = $80000000;

type
  CK_MECHANISM_TYPE_PTR = ^CK_MECHANISM_TYPE;

  {+// CK_MECHANISM is a structure that specifies a particular }
  {=* mechanism }
  CK_MECHANISM = record
    mechanism: CK_MECHANISM_TYPE;
    pParameter: CK_VOID_PTR;
    {+// ulParameterLen was changed from CK_USHORT to CK_ULONG for v2.0 }
    ulParameterLen: CK_ULONG;           {= in bytes }
  end {CK_MECHANISM};
  CK_MECHANISM_PTR = ^CK_MECHANISM;

  {+// CK_MECHANISM_INFO provides information about a particular }
  {=* mechanism }
  CK_MECHANISM_INFO = record
    ulMinKeySize: CK_ULONG;
    ulMaxKeySize: CK_ULONG;
    flags: CK_FLAGS;
  end {CK_MECHANISM_INFO};

  {+// The flags are defined as follows: }
  {=* Bit Flag Mask Meaning }
const
  CKF_HW = $00000001;        {/* performed by HW*/}

  {+// The flags CKF_ENCRYPT, CKF_DECRYPT, CKF_DIGEST, CKF_SIGN, }
  {-* CKG_SIGN_RECOVER, CKF_VERIFY, CKF_VERIFY_RECOVER, }
  {-* CKF_GENERATE, CKF_GENERATE_KEY_PAIR, CKF_WRAP, CKF_UNWRAP, }
  {-* and CKF_DERIVE are new for v2.0. They specify whether or not }
  {=* a mechanism can be used for a particular task }
  CKF_ENCRYPT = $00000100;
  CKF_DECRYPT = $00000200;
  CKF_DIGEST = $00000400;
  CKF_SIGN = $00000800;
  CKF_SIGN_RECOVER = $00001000;
  CKF_VERIFY = $00002000;
  CKF_VERIFY_RECOVER = $00004000;
  CKF_GENERATE = $00008000;
  CKF_GENERATE_KEY_PAIR = $00010000;
  CKF_WRAP = $00020000;
  CKF_UNWRAP = $00040000;
  CKF_DERIVE = $00080000;

  {+// CKF_EC_F_P, CKF_EC_F_2M, CKF_EC_ECPARAMETERS, CKF_EC_NAMEDCURVE, }
  {-* CKF_EC_UNCOMPRESS, and CKF_EC_COMPRESS are new for v2.11. They }
  {-* describe a token's EC capabilities not available in mechanism }
  {=* information. }
  CKF_EC_F_P = $00100000;
  CKF_EC_F_2M = $00200000;
  CKF_EC_ECPARAMETERS = $00400000;
  CKF_EC_NAMEDCURVE = $00800000;
  CKF_EC_UNCOMPRESS = $01000000;
  CKF_EC_COMPRESS = $02000000;

  CKF_EXTENSION = $80000000;        {/* FALSE for 2.01*/}

type
  CK_MECHANISM_INFO_PTR = ^CK_MECHANISM_INFO;

  {+// CK_RV is a value that identifies the return value of a }
  {=* Cryptoki function }
  {+// CK_RV was changed from CK_USHORT to CK_ULONG for v2.0*/ }
  CK_RV = CK_ULONG;

const
  CKR_OK = $00000000;
  CKR_CANCEL = $00000001;
  CKR_HOST_MEMORY = $00000002;
  CKR_SLOT_ID_INVALID = $00000003;

  {+// CKR_FLAGS_INVALID was removed for v2.0*/ }

  {+// CKR_GENERAL_ERROR and CKR_FUNCTION_FAILED are new for v2.0*/ }
  CKR_GENERAL_ERROR = $00000005;
  CKR_FUNCTION_FAILED = $00000006;

  {+// CKR_ARGUMENTS_BAD, CKR_NO_EVENT, CKR_NEED_TO_CREATE_THREADS, }
  {=* and CKR_CANT_LOCK are new for v2.01 }
  CKR_ARGUMENTS_BAD = $00000007;
  CKR_NO_EVENT = $00000008;
  CKR_NEED_TO_CREATE_THREADS = $00000009;
  CKR_CANT_LOCK = $0000000A;

  CKR_ATTRIBUTE_READ_ONLY = $00000010;
  CKR_ATTRIBUTE_SENSITIVE = $00000011;
  CKR_ATTRIBUTE_TYPE_INVALID = $00000012;
  CKR_ATTRIBUTE_VALUE_INVALID = $00000013;
  CKR_DATA_INVALID = $00000020;
  CKR_DATA_LEN_RANGE = $00000021;
  CKR_DEVICE_ERROR = $00000030;
  CKR_DEVICE_MEMORY = $00000031;
  CKR_DEVICE_REMOVED = $00000032;
  CKR_ENCRYPTED_DATA_INVALID = $00000040;
  CKR_ENCRYPTED_DATA_LEN_RANGE = $00000041;
  CKR_FUNCTION_CANCELED = $00000050;
  CKR_FUNCTION_NOT_PARALLEL = $00000051;

  {+// CKR_FUNCTION_NOT_SUPPORTED is new for v2.0*/ }
  CKR_FUNCTION_NOT_SUPPORTED = $00000054;

  CKR_KEY_HANDLE_INVALID = $00000060;

  {+// CKR_KEY_SENSITIVE was removed for v2.0*/ }

  CKR_KEY_SIZE_RANGE = $00000062;
  CKR_KEY_TYPE_INCONSISTENT = $00000063;

  {+// CKR_KEY_NOT_NEEDED, CKR_KEY_CHANGED, CKR_KEY_NEEDED, }
  {-* CKR_KEY_INDIGESTIBLE, CKR_KEY_FUNCTION_NOT_PERMITTED, }
  {-* CKR_KEY_NOT_WRAPPABLE, and CKR_KEY_UNEXTRACTABLE are new for }
  {=* v2.0 }
  CKR_KEY_NOT_NEEDED = $00000064;
  CKR_KEY_CHANGED = $00000065;
  CKR_KEY_NEEDED = $00000066;
  CKR_KEY_INDIGESTIBLE = $00000067;
  CKR_KEY_FUNCTION_NOT_PERMITTED = $00000068;
  CKR_KEY_NOT_WRAPPABLE = $00000069;
  CKR_KEY_UNEXTRACTABLE = $0000006A;

  CKR_MECHANISM_INVALID = $00000070;
  CKR_MECHANISM_PARAM_INVALID = $00000071;

  {+// CKR_OBJECT_CLASS_INCONSISTENT and CKR_OBJECT_CLASS_INVALID }
  {=* were removed for v2.0 }
  CKR_OBJECT_HANDLE_INVALID = $00000082;
  CKR_OPERATION_ACTIVE = $00000090;
  CKR_OPERATION_NOT_INITIALIZED = $00000091;
  CKR_PIN_INCORRECT = $000000A0;
  CKR_PIN_INVALID = $000000A1;
  CKR_PIN_LEN_RANGE = $000000A2;

  {+// CKR_PIN_EXPIRED and CKR_PIN_LOCKED are new for v2.0*/ }
  CKR_PIN_EXPIRED = $000000A3;
  CKR_PIN_LOCKED = $000000A4;

  CKR_SESSION_CLOSED = $000000B0;
  CKR_SESSION_COUNT = $000000B1;
  CKR_SESSION_HANDLE_INVALID = $000000B3;
  CKR_SESSION_PARALLEL_NOT_SUPPORTED = $000000B4;
  CKR_SESSION_READ_ONLY = $000000B5;
  CKR_SESSION_EXISTS = $000000B6;

  {+// CKR_SESSION_READ_ONLY_EXISTS and }
  {=* CKR_SESSION_READ_WRITE_SO_EXISTS are new for v2.0 }
  CKR_SESSION_READ_ONLY_EXISTS = $000000B7;
  CKR_SESSION_READ_WRITE_SO_EXISTS = $000000B8;

  CKR_SIGNATURE_INVALID = $000000C0;
  CKR_SIGNATURE_LEN_RANGE = $000000C1;
  CKR_TEMPLATE_INCOMPLETE = $000000D0;
  CKR_TEMPLATE_INCONSISTENT = $000000D1;
  CKR_TOKEN_NOT_PRESENT = $000000E0;
  CKR_TOKEN_NOT_RECOGNIZED = $000000E1;
  CKR_TOKEN_WRITE_PROTECTED = $000000E2;
  CKR_UNWRAPPING_KEY_HANDLE_INVALID = $000000F0;
  CKR_UNWRAPPING_KEY_SIZE_RANGE = $000000F1;
  CKR_UNWRAPPING_KEY_TYPE_INCONSISTENT = $000000F2;
  CKR_USER_ALREADY_LOGGED_IN = $00000100;
  CKR_USER_NOT_LOGGED_IN = $00000101;
  CKR_USER_PIN_NOT_INITIALIZED = $00000102;
  CKR_USER_TYPE_INVALID = $00000103;

  {+// CKR_USER_ANOTHER_ALREADY_LOGGED_IN and CKR_USER_TOO_MANY_TYPES }
  {=* are new to v2.01 }
  CKR_USER_ANOTHER_ALREADY_LOGGED_IN = $00000104;
  CKR_USER_TOO_MANY_TYPES = $00000105;

  CKR_WRAPPED_KEY_INVALID = $00000110;
  CKR_WRAPPED_KEY_LEN_RANGE = $00000112;
  CKR_WRAPPING_KEY_HANDLE_INVALID = $00000113;
  CKR_WRAPPING_KEY_SIZE_RANGE = $00000114;
  CKR_WRAPPING_KEY_TYPE_INCONSISTENT = $00000115;
  CKR_RANDOM_SEED_NOT_SUPPORTED = $00000120;

  {+// These are new to v2.0*/ }
  CKR_RANDOM_NO_RNG = $00000121;

  {+// These are new to v2.11*/ }
  CKR_DOMAIN_PARAMS_INVALID = $00000130;

  {+// These are new to v2.0*/ }
  CKR_BUFFER_TOO_SMALL = $00000150;
  CKR_SAVED_STATE_INVALID = $00000160;
  CKR_INFORMATION_SENSITIVE = $00000170;
  CKR_STATE_UNSAVEABLE = $00000180;

  {+// These are new to v2.01*/ }
  CKR_CRYPTOKI_NOT_INITIALIZED = $00000190;
  CKR_CRYPTOKI_ALREADY_INITIALIZED = $00000191;
  CKR_MUTEX_BAD = $000001A0;
  CKR_MUTEX_NOT_LOCKED = $000001A1;

  {+// This is new to v2.20 */ }
  CKR_FUNCTION_REJECTED = $00000200;

  CKR_VENDOR_DEFINED = $80000000;

  //  CK_CALLBACK_FUNCTION(RV, Name) = function name(...): RV;

  //* CK_NOTIFY is an application callback that processes events */
type
  CK_NOTIFY = function(
    hSession: CK_SESSION_HANDLE;        //* the session's handle */
    event: CK_NOTIFICATION;
    pApplication: CK_VOID_PTR           //* passed to C_OpenSession */
    ): CK_RV;


  {+// CK_FUNCTION_LIST is a structure holding a Cryptoki spec }
  {-* version and pointers of appropriate types to all the }
  {=* Cryptoki functions }
  {+// CK_FUNCTION_LIST is new for v2.0*/ }

  CK_FUNCTION_LIST_PTR = ^CK_FUNCTION_LIST;

  CK_FUNCTION_LIST_PTR_PTR = ^CK_FUNCTION_LIST_PTR;

  {/* C_Initialize initializes the Cryptoki library. */}
  TfC_Initialize = function(
    pInitArgs: CK_VOID_PTR {/* if this is not NULL_PTR, it gets cast to CK_C_INITIALIZE_ARGS_PTR and dereferenced */}
    ): CK_RV; cdecl;

  {/* C_Finalize indicates that an application is done with the
    * Cryptoki library. */}
  TfC_Finalize = function(
    pReserved: CK_VOID_PTR              {/* reserved.  Should be NULL_PTR */}
    ): CK_RV; cdecl;

  {/* C_GetInfo returns general information about Cryptoki. */}
  TfC_GetInfo = function(
    pInfo: CK_INFO_PTR                  {/* location that receives information */}
    ): CK_RV; cdecl;

  {/* C_GetFunctionList returns the function list. */}
  TfC_GetFunctionList = function(
    ppFunctionList: CK_FUNCTION_LIST_PTR_PTR {/* receives pointer to
    * function list */}
    ): CK_RV; cdecl;

  {/* Slot and token management */}

  {/* C_GetSlotList obtains a list of slots in the system. */}
  TfC_GetSlotList = function(
    tokenPresent: CK_BBOOL;             {/* only slots with tokens? */}
    pSlotList: CK_SLOT_ID_PTR;          {/* receives array of slot IDs */}
    pulCount: CK_ULONG_PTR              {/* receives number of slots */}
    ): CK_RV; cdecl;

  {/* C_GetSlotInfo obtains information about a particular slot in
    * the system. */}
  TfC_GetSlotInfo = function(
    slotID: CK_SLOT_ID;                 {/* the ID of the slot */}
    pInfo: CK_SLOT_INFO_PTR             {/* receives the slot information */}
    ): CK_RV; cdecl;

  {/* C_GetTokenInfo obtains information about a particular token
    * in the system. */}
  TfC_GetTokenInfo = function(
    slotID: CK_SLOT_ID;                 {/* ID of the token's slot */}
    pInfo: CK_TOKEN_INFO_PTR            {/* receives the token information */}
    ): CK_RV; cdecl;

  {/* C_GetMechanismList obtains a list of mechanism types
    * supported by a token. */}
  TfC_GetMechanismList = function(
    slotID: CK_SLOT_ID;                 {/* ID of token's slot */}
    pMechanismList: CK_MECHANISM_TYPE_PTR; {/* gets mech. array */}
    pulCount: CK_ULONG_PTR              {/* gets # of mechs. */}
    ): CK_RV; cdecl;

  {/* C_GetMechanismInfo obtains information about a particular
    * mechanism possibly supported by a token. */}
  TfC_GetMechanismInfo = function(
    slotID: CK_SLOT_ID;                 {/* ID of the token's slot */}
    _type: CK_MECHANISM_TYPE;           {/* type of mechanism */}
    pInfo: CK_MECHANISM_INFO_PTR        {/* receives mechanism info */}
    ): CK_RV; cdecl;

  {/* C_InitToken initializes a token. */}
  TfC_InitToken = function(
    slotID: CK_SLOT_ID;                 {/* ID of the token's slot */}
    pPin: CK_UTF8CHAR_PTR;              {/* the SO's initial PIN */}
    ulPinLen: CK_ULONG;                 {/* length in bytes of the PIN */}
    pLabel: CK_UTF8CHAR_PTR             {/* 32-byte token label (blank padded) */}
    ): CK_RV; cdecl;

  {/* C_InitPIN initializes the normal user's PIN. */}
  TfC_InitPIN = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    pPin: CK_UTF8CHAR_PTR;              {/* the normal user's PIN */}
    ulPinLen: CK_ULONG                  {/* length in bytes of the PIN */}
    ): CK_RV; cdecl;

  {/* C_SetPIN modifies the PIN of the user who is logged in. */}
  TfC_SetPIN = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    pOldPin: CK_UTF8CHAR_PTR;           {/* the old PIN */}
    ulOldLen: CK_ULONG;                 {/* length of the old PIN */}
    pNewPin: CK_UTF8CHAR_PTR;           {/* the new PIN */}
    ulNewLen: CK_ULONG                  {/* length of the new PIN */}
    ): CK_RV; cdecl;

  {/* Session management */}

  {/* C_OpenSession opens a session between an application and a
    * token. */}
  TfC_OpenSession = function(
    slotID: CK_SLOT_ID;                 {/* the slot's ID */}
    flags: CK_FLAGS;                    {/* from CK_SESSION_INFO */}
    pApplication: CK_VOID_PTR;          {/* passed to callback */}
    Notify: CK_NOTIFY;                  {/* callback function */}
    phSession: CK_SESSION_HANDLE_PTR    {/* gets session handle */}
    ): CK_RV; cdecl;

  {/* C_CloseSession closes a session between an application and a
    * token. */}
  TfC_CloseSession = function(
    hSession: CK_SESSION_HANDLE         {/* the session's handle */}
    ): CK_RV; cdecl;

  {/* C_CloseAllSessions closes all sessions with a token. */}
  TfC_CloseAllSessions = function(
    slotID: CK_SLOT_ID                  {/* the token's slot */}
    ): CK_RV; cdecl;

  {/* C_GetSessionInfo obtains information about the session. */}
  TfC_GetSessionInfo = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    pInfo: CK_SESSION_INFO_PTR          {/* receives session info */}
    ): CK_RV; cdecl;

  {/* C_GetOperationState obtains the state of the cryptographic operation
    * in a session. */}
  TfC_GetOperationState = function(
    hSession: CK_SESSION_HANDLE;        {/* session's handle */}
    pOperationState: CK_BYTE_PTR;       {/* gets state */}
    pulOperationStateLen: CK_ULONG_PTR  {/* gets state length */}
    ): CK_RV; cdecl;

  {/* C_SetOperationState restores the state of the cryptographic
    * operation in a session. */}
  TfC_SetOperationState = function(
    hSession: CK_SESSION_HANDLE;        {/* session's handle */}
    pOperationState: CK_BYTE_PTR;       {/* holds state */}
    ulOperationStateLen: CK_ULONG;      {/* holds state length */}
    hEncryptionKey: CK_OBJECT_HANDLE;   {/* en/decryption key */}
    hAuthenticationKey: CK_OBJECT_HANDLE {/* sign/verify key */}
    ): CK_RV; cdecl;

  {/* C_Login logs a user into a token. */}
  TfC_Login = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    userType: CK_USER_TYPE;             {/* the user type */}
    pPin: CK_UTF8CHAR_PTR;              {/* the user's PIN */}
    ulPinLen: CK_ULONG                  {/* the length of the PIN */}
    ): CK_RV; cdecl;

  {/* C_Logout logs a user out from a token. */}
  TfC_Logout = function(
    hSession: CK_SESSION_HANDLE         {/* the session's handle */}
    ): CK_RV; cdecl;

  {/* Object management */}

  {/* C_CreateObject creates a new object. */}
  TfC_CreateObject = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    pTemplate: CK_ATTRIBUTE_PTR;        {/* the object's template */}
    ulCount: CK_ULONG;                  {/* attributes in template */}
    phObject: CK_OBJECT_HANDLE_PTR      {/* gets new object's handle. */}
    ): CK_RV; cdecl;

  {/* C_CopyObject copies an object; creating a new object for the
    * copy. */}
  TfC_CopyObject = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    hObject: CK_OBJECT_HANDLE;          {/* the object's handle */}
    pTemplate: CK_ATTRIBUTE_PTR;        {/* template for new object */}
    ulCount: CK_ULONG;                  {/* attributes in template */}
    phNewObject: CK_OBJECT_HANDLE_PTR   {/* receives handle of copy */}
    ): CK_RV; cdecl;

  {/* C_DestroyObject destroys an object. */}
  TfC_DestroyObject = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    hObject: CK_OBJECT_HANDLE           {/* the object's handle */}
    ): CK_RV; cdecl;

  {/* C_GetObjectSize gets the size of an object in bytes. */}
  TfC_GetObjectSize = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    hObject: CK_OBJECT_HANDLE;          {/* the object's handle */}
    pulSize: CK_ULONG_PTR               {/* receives size of object */}
    ): CK_RV; cdecl;

  {/* C_GetAttributeValue obtains the value of one or more object
    * attributes. */}
  TfC_GetAttributeValue = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    hObject: CK_OBJECT_HANDLE;          {/* the object's handle */}
    pTemplate: CK_ATTRIBUTE_PTR;        {/* specifies attrs; gets vals */}
    ulCount: CK_ULONG                   {/* attributes in template */}
    ): CK_RV; cdecl;

  {/* C_SetAttributeValue modifies the value of one or more object
    * attributes */}
  TfC_SetAttributeValue = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    hObject: CK_OBJECT_HANDLE;          {/* the object's handle */}
    pTemplate: CK_ATTRIBUTE_PTR;        {/* specifies attrs and values */}
    ulCount: CK_ULONG                   {/* attributes in template */}
    ): CK_RV; cdecl;

  {/* C_FindObjectsInit initializes a search for token and session
    * objects that match a template. */}
  TfC_FindObjectsInit = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    pTemplate: CK_ATTRIBUTE_PTR;        {/* attribute values to match */}
    ulCount: CK_ULONG                   {/* attrs in search template */}
    ): CK_RV; cdecl;

  {/* C_FindObjects continues a search for token and session
    * objects that match a template; obtaining additional object
    * handles. */}
  TfC_FindObjects = function(
    hSession: CK_SESSION_HANDLE;        {/* session's handle */}
    phObject: CK_OBJECT_HANDLE_PTR;     {/* gets obj. handles */}
    ulMaxObjectCount: CK_ULONG;         {/* max handles to get */}
    pulObjectCount: CK_ULONG_PTR        {/* actual # returned */}
    ): CK_RV; cdecl;

  {/* C_FindObjectsFinal finishes a search for token and session
    * objects. */}
  TfC_FindObjectsFinal = function(
    hSession: CK_SESSION_HANDLE         {/* the session's handle */}
    ): CK_RV; cdecl;

  {/* Encryption and decryption */}

  {/* C_EncryptInit initializes an encryption operation. */}
  TfC_EncryptInit = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    pMechanism: CK_MECHANISM_PTR;       {/* the encryption mechanism */}
    hKey: CK_OBJECT_HANDLE              {/* handle of encryption key */}
    ): CK_RV; cdecl;

  {/* C_Encrypt encrypts single-part data. */}
  TfC_Encrypt = function(
    hSession: CK_SESSION_HANDLE;        {/* session's handle */}
    pData: CK_BYTE_PTR;                 {/* the plaintext data */}
    ulDataLen: CK_ULONG;                {/* bytes of plaintext */}
    pEncryptedData: CK_BYTE_PTR;        {/* gets ciphertext */}
    pulEncryptedDataLen: CK_ULONG_PTR   {/* gets c-text size */}
    ): CK_RV; cdecl;

  {/* C_EncryptUpdate continues a multiple-part encryption
    * operation. */}
  TfC_EncryptUpdate = function(
    hSession: CK_SESSION_HANDLE;        {/* session's handle */}
    pPart: CK_BYTE_PTR;                 {/* the plaintext data */}
    ulPartLen: CK_ULONG;                {/* plaintext data len */}
    pEncryptedPart: CK_BYTE_PTR;        {/* gets ciphertext */}
    pulEncryptedPartLen: CK_ULONG_PTR   {/* gets c-text size */}
    ): CK_RV; cdecl;

  {/* C_EncryptFinal finishes a multiple-part encryption
    * operation. */}
  TfC_EncryptFinal = function(
    hSession: CK_SESSION_HANDLE;        {/* session handle */}
    pLastEncryptedPart: CK_BYTE_PTR;    {/* last c-text */}
    pulLastEncryptedPartLen: CK_ULONG_PTR {/* gets last size */}
    ): CK_RV; cdecl;

  {/* C_DecryptInit initializes a decryption operation. */}
  TfC_DecryptInit = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    pMechanism: CK_MECHANISM_PTR;       {/* the decryption mechanism */}
    hKey: CK_OBJECT_HANDLE              {/* handle of decryption key */}
    ): CK_RV; cdecl;

  {/* C_Decrypt decrypts encrypted data in a single part. */}
  TfC_Decrypt = function(
    hSession: CK_SESSION_HANDLE;        {/* session's handle */}
    pEncryptedData: CK_BYTE_PTR;        {/* ciphertext */}
    ulEncryptedDataLen: CK_ULONG;       {/* ciphertext length */}
    pData: CK_BYTE_PTR;                 {/* gets plaintext */}
    pulDataLen: CK_ULONG_PTR            {/* gets p-text size */}
    ): CK_RV; cdecl;

  {/* C_DecryptUpdate continues a multiple-part decryption
    * operation. */}
  TfC_DecryptUpdate = function(
    hSession: CK_SESSION_HANDLE;        {/* session's handle */}
    pEncryptedPart: CK_BYTE_PTR;        {/* encrypted data */}
    ulEncryptedPartLen: CK_ULONG;       {/* input length */}
    pPart: CK_BYTE_PTR;                 {/* gets plaintext */}
    pulPartLen: CK_ULONG_PTR            {/* p-text size */}
    ): CK_RV; cdecl;

  {/* C_DecryptFinal finishes a multiple-part decryption
    * operation. */}
  TfC_DecryptFinal = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    pLastPart: CK_BYTE_PTR;             {/* gets plaintext */}
    pulLastPartLen: CK_ULONG_PTR        {/* p-text size */}
    ): CK_RV; cdecl;

  {/* Message digesting */}

  {/* C_DigestInit initializes a message-digesting operation. */}
  TfC_DigestInit = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    pMechanism: CK_MECHANISM_PTR        {/* the digesting mechanism */}
    ): CK_RV; cdecl;

  {/* C_Digest digests data in a single part. */}
  TfC_Digest = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    pData: CK_BYTE_PTR;                 {/* data to be digested */}
    ulDataLen: CK_ULONG;                {/* bytes of data to digest */}
    pDigest: CK_BYTE_PTR;               {/* gets the message digest */}
    pulDigestLen: CK_ULONG_PTR          {/* gets digest length */}
    ): CK_RV; cdecl;

  {/* C_DigestUpdate continues a multiple-part message-digesting
    * operation. */}
  TfC_DigestUpdate = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    pPart: CK_BYTE_PTR;                 {/* data to be digested */}
    ulPartLen: CK_ULONG                 {/* bytes of data to be digested */}
    ): CK_RV; cdecl;

  {/* C_DigestKey continues a multi-part message-digesting
    * operation; by digesting the value of a secret key as part of
    * the data already digested. */}
  TfC_DigestKey = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    hKey: CK_OBJECT_HANDLE              {/* secret key to digest */}
    ): CK_RV; cdecl;

  {/* C_DigestFinal finishes a multiple-part message-digesting
    * operation. */}
  TfC_DigestFinal = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    pDigest: CK_BYTE_PTR;               {/* gets the message digest */}
    pulDigestLen: CK_ULONG_PTR          {/* gets byte count of digest */}
    ): CK_RV; cdecl;

  {/* Signing and MACing */}

  {/* C_SignInit initializes a signature (private key encryption
    * operation; where the signature is (will be) an appendix to
    * the data; and plaintext cannot be recovered from the
   *signature. */}
  TfC_SignInit = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    pMechanism: CK_MECHANISM_PTR;       {/* the signature mechanism */}
    hKey: CK_OBJECT_HANDLE              {/* handle of signature key */}
    ): CK_RV; cdecl;

  {/* C_Sign signs (encrypts with private key) data in a single
    * part; where the signature is (will be) an appendix to the
    * data; and plaintext cannot be recovered from the signature. */}
  TfC_Sign = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    pData: CK_BYTE_PTR;                 {/* the data to sign */}
    ulDataLen: CK_ULONG;                {/* count of bytes to sign */}
    pSignature: CK_BYTE_PTR;            {/* gets the signature */}
    pulSignatureLen: CK_ULONG_PTR       {/* gets signature length */}
    ): CK_RV; cdecl;

  {/* C_SignUpdate continues a multiple-part signature operation,
    * where the signature is (will be) an appendix to the data,
    * and plaintext cannot be recovered from the signature. */}
  TfC_SignUpdate = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    pPart: CK_BYTE_PTR;                 {/* the data to sign */}
    ulPartLen: CK_ULONG                 {/* count of bytes to sign */}
    ): CK_RV; cdecl;

  {/* C_SignFinal finishes a multiple-part signature operation,
    * returning the signature. */}
  TfC_SignFinal = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    pSignature: CK_BYTE_PTR;            {/* gets the signature */}
    pulSignatureLen: CK_ULONG_PTR       {/* gets signature length */}
    ): CK_RV; cdecl;

  {/* C_SignRecoverInit initializes a signature operation; where
    * the data can be recovered from the signature. */}
  TfC_SignRecoverInit = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    pMechanism: CK_MECHANISM_PTR;       {/* the signature mechanism */}
    hKey: CK_OBJECT_HANDLE              {/* handle of the signature key */}
    ): CK_RV; cdecl;

  {/* C_SignRecover signs data in a single operation; where the
    * data can be recovered from the signature. */}
  TfC_SignRecover = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    pData: CK_BYTE_PTR;                 {/* the data to sign */}
    ulDataLen: CK_ULONG;                {/* count of bytes to sign */}
    pSignature: CK_BYTE_PTR;            {/* gets the signature */}
    pulSignatureLen: CK_ULONG_PTR       {/* gets signature length */}
    ): CK_RV; cdecl;

  {/* Verifying signatures and MACs */}

  {/* C_VerifyInit initializes a verification operation; where the
    * signature is an appendix to the data; and plaintext cannot
    *  cannot be recovered from the signature (e.g. DSA). */}
  TfC_VerifyInit = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    pMechanism: CK_MECHANISM_PTR;       {/* the verification mechanism */}
    hKey: CK_OBJECT_HANDLE              {/* verification key */}
    ): CK_RV; cdecl;

  {/* C_Verify verifies a signature in a single-part operation,
    * where the signature is an appendix to the data; and plaintext
    * cannot be recovered from the signature. */}
  TfC_Verify = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    pData: CK_BYTE_PTR;                 {/* signed data */}
    ulDataLen: CK_ULONG;                {/* length of signed data */}
    pSignature: CK_BYTE_PTR;            {/* signature */}
    ulSignatureLen: CK_ULONG            {/* signature length*/}
    ): CK_RV; cdecl;

  {/* C_VerifyUpdate continues a multiple-part verification
    * operation; where the signature is an appendix to the data,
    * and plaintext cannot be recovered from the signature. */}
  TfC_VerifyUpdate = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    pPart: CK_BYTE_PTR;                 {/* signed data */}
    ulPartLen: CK_ULONG                 {/* length of signed data */}
    ): CK_RV; cdecl;

  {/* C_VerifyFinal finishes a multiple-part verification
    * operation; checking the signature. */}
  TfC_VerifyFinal = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    pSignature: CK_BYTE_PTR;            {/* signature to verify */}
    ulSignatureLen: CK_ULONG            {/* signature length */}
    ): CK_RV; cdecl;

  {/* C_VerifyRecoverInit initializes a signature verification
    * operation; where the data is recovered from the signature. */}
  TfC_VerifyRecoverInit = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    pMechanism: CK_MECHANISM_PTR;       {/* the verification mechanism */}
    hKey: CK_OBJECT_HANDLE              {/* verification key */}
    ): CK_RV; cdecl;

  {/* C_VerifyRecover verifies a signature in a single-part
    * operation; where the data is recovered from the signature. */}
  TfC_VerifyRecover = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    pSignature: CK_BYTE_PTR;            {/* signature to verify */}
    ulSignatureLen: CK_ULONG;           {/* signature length */}
    pData: CK_BYTE_PTR;                 {/* gets signed data */}
    pulDataLen: CK_ULONG_PTR            {/* gets signed data len */}
    ): CK_RV; cdecl;

  {/* Dual-function cryptographic operations */}

  {/* C_DigestEncryptUpdate continues a multiple-part digesting
    * and encryption operation. */}
  TfC_DigestEncryptUpdate = function(
    hSession: CK_SESSION_HANDLE;        {/* session's handle */}
    pPart: CK_BYTE_PTR;                 {/* the plaintext data */}
    ulPartLen: CK_ULONG;                {/* plaintext length */}
    pEncryptedPart: CK_BYTE_PTR;        {/* gets ciphertext */}
    pulEncryptedPartLen: CK_ULONG_PTR   {/* gets c-text length */}
    ): CK_RV; cdecl;

  {/* C_DecryptDigestUpdate continues a multiple-part decryption and
    * digesting operation. */}
  TfC_DecryptDigestUpdate = function(
    hSession: CK_SESSION_HANDLE;        {/* session's handle */}
    pEncryptedPart: CK_BYTE_PTR;        {/* ciphertext */}
    ulEncryptedPartLen: CK_ULONG;       {/* ciphertext length */}
    pPart: CK_BYTE_PTR;                 {/* gets plaintext */}
    pulPartLen: CK_ULONG_PTR            {/* gets plaintext len */}
    ): CK_RV; cdecl;

  {/* C_SignEncryptUpdate continues a multiple-part signing and
    * encryption operation. */}
  TfC_SignEncryptUpdate = function(
    hSession: CK_SESSION_HANDLE;        {/* session's handle */}
    pPart: CK_BYTE_PTR;                 {/* the plaintext data */}
    ulPartLen: CK_ULONG;                {/* plaintext length */}
    pEncryptedPart: CK_BYTE_PTR;        {/* gets ciphertext */}
    pulEncryptedPartLen: CK_ULONG_PTR   {/* gets c-text length */}
    ): CK_RV; cdecl;

  {/* C_DecryptVerifyUpdate continues a multiple-part decryption and
    * verify operation. */}
  TfC_DecryptVerifyUpdate = function(
    hSession: CK_SESSION_HANDLE;        {/* session's handle */}
    pEncryptedPart: CK_BYTE_PTR;        {/* ciphertext */}
    ulEncryptedPartLen: CK_ULONG;       {/* ciphertext length */}
    pPart: CK_BYTE_PTR;                 {/* gets plaintext */}
    pulPartLen: CK_ULONG_PTR            {/* gets p-text length */}
    ): CK_RV; cdecl;

  {/* Key management */}

  {/* C_GenerateKey generates a secret key; creating a new key
    * object. */}
  TfC_GenerateKey = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    pMechanism: CK_MECHANISM_PTR;       {/* key generation mech. */}
    pTemplate: CK_ATTRIBUTE_PTR;        {/* template for new key */}
    ulCount: CK_ULONG;                  {/* # of attrs in template */}
    phKey: CK_OBJECT_HANDLE_PTR         {/* gets handle of new key */}
    ): CK_RV; cdecl;

  {/* C_GenerateKeyPair generates a public-key/private-key pair,
    * creating new key objects. */}
  TfC_GenerateKeyPair = function(
    hSession: CK_SESSION_HANDLE;        {/* session handle */}
    pMechanism: CK_MECHANISM_PTR;       {/* key-gen mech. */}
    pPublicKeyTemplate: CK_ATTRIBUTE_PTR; {/* template for pub. key */}
    ulPublicKeyAttributeCount: CK_ULONG; {/* # pub. attrs. */}
    pPrivateKeyTemplate: CK_ATTRIBUTE_PTR; {/* template for priv. key */}
    ulPrivateKeyAttributeCount: CK_ULONG; {/* # priv. attrs. */}
    phPublicKey: CK_OBJECT_HANDLE_PTR;  {/* gets pub. key handle */}
    phPrivateKey: CK_OBJECT_HANDLE_PTR  {/* gets priv. key handle */}
    ): CK_RV; cdecl;

  {/* C_WrapKey wraps (i.e.; encrypts) a key. */}
  TfC_WrapKey = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    pMechanism: CK_MECHANISM_PTR;       {/* the wrapping mechanism */}
    hWrappingKey: CK_OBJECT_HANDLE;     {/* wrapping key */}
    hKey: CK_OBJECT_HANDLE;             {/* key to be wrapped */}
    pWrappedKey: CK_BYTE_PTR;           {/* gets wrapped key */}
    pulWrappedKeyLen: CK_ULONG_PTR      {/* gets wrapped key size */}
    ): CK_RV; cdecl;

  {/* C_UnwrapKey unwraps (decrypts) a wrapped key; creating a new
    * key object. */}
  TfC_UnwrapKey = function(
    hSession: CK_SESSION_HANDLE;        {/* session's handle */}
    pMechanism: CK_MECHANISM_PTR;       {/* unwrapping mech. */}
    hUnwrappingKey: CK_OBJECT_HANDLE;   {/* unwrapping key */}
    pWrappedKey: CK_BYTE_PTR;           {/* the wrapped key */}
    ulWrappedKeyLen: CK_ULONG;          {/* wrapped key len */}
    pTemplate: CK_ATTRIBUTE_PTR;        {/* new key template */}
    ulAttributeCount: CK_ULONG;         {/* template length */}
    phKey: CK_OBJECT_HANDLE_PTR         {/* gets new handle */}
    ): CK_RV; cdecl;

  {/* C_DeriveKey derives a key from a base key; creating a new key
    * object. */}
  TfC_DeriveKey = function(
    hSession: CK_SESSION_HANDLE;        {/* session's handle */}
    pMechanism: CK_MECHANISM_PTR;       {/* key deriv. mech. */}
    hBaseKey: CK_OBJECT_HANDLE;         {/* base key */}
    pTemplate: CK_ATTRIBUTE_PTR;        {/* new key template */}
    ulAttributeCount: CK_ULONG;         {/* template length */}
    phKey: CK_OBJECT_HANDLE_PTR         {/* gets new handle */}
    ): CK_RV; cdecl;

  {/* Random number generation */}

  {/* C_SeedRandom mixes additional seed material into the token's
    * random number generator. */}
  TfC_SeedRandom = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    pSeed: CK_BYTE_PTR;                 {/* the seed material */}
    ulSeedLen: CK_ULONG                 {/* length of seed material */}
    ): CK_RV; cdecl;

  {/* C_GenerateRandom generates random data. */}
  TfC_GenerateRandom = function(
    hSession: CK_SESSION_HANDLE;        {/* the session's handle */}
    RandomData: CK_BYTE_PTR;            {/* receives the random data */}
    ulRandomLen: CK_ULONG               {/* # of bytes to generate */}
    ): CK_RV; cdecl;

  {/* Parallel function management */}

  {/* C_GetFunctionStatus is a legacy function; it obtains an
    * updated status of a function running in parallel with an
    * application. */}
  TfC_GetFunctionStatus = function(
    hSession: CK_SESSION_HANDLE         {/* the session's handle */}
    ): CK_RV; cdecl;

  {/* C_CancelFunction is a legacy function; it cancels a function
    * running in parallel. */}
  TfC_CancelFunction = function(
    hSession: CK_SESSION_HANDLE         {/* the session's handle */}
    ): CK_RV; cdecl;

  {/* Functions added in for Cryptoki Version 2.01 or later */}

  {/* C_WaitForSlotEvent waits for a slot event (token insertion,
    * removal; etc.) to occur. */}
  TfC_WaitForSlotEvent = function(
    flags: CK_FLAGS;                    {/* blocking/nonblocking flag */}
    pSlot: CK_SLOT_ID_PTR;              {/* location that receives the slot ID */}
    pRserved: CK_VOID_PTR               {/* reserved.  Should be NULL_PTR */}
    ): CK_RV; cdecl;

  //
  // CK_FUNCTION_LIST RECORD
  //
  CK_FUNCTION_LIST = packed record
    Version: CK_VERSION;
    C_Initialize: TfC_Initialize;
    C_Finalize: TfC_Finalize;
    C_GetInfo: TfC_GetInfo;
    C_GetFunctionList: TfC_GetFunctionList;
    C_GetSlotList: TfC_GetSlotList;
    C_GetSlotInfo: TfC_GetSlotInfo;
    C_GetTokenInfo: TfC_GetTokenInfo;
    C_GetMechanismList: TfC_GetMechanismList;
    C_GetMechanismInfo: TfC_GetMechanismInfo;
    C_InitToken: TfC_InitToken;
    C_InitPIN: TfC_InitPIN;
    C_SetPIN: TfC_SetPIN;
    C_OpenSession: TfC_OpenSession;
    C_CloseSession: TfC_CloseSession;
    C_CloseAllSessions: TfC_CloseAllSessions;
    C_GetSessionInfo: TfC_GetSessionInfo;
    C_GetOperationState: TfC_GetOperationState;
    C_SetOperationState: TfC_SetOperationState;
    C_Login: TfC_Login;
    C_Logout: TfC_Logout;
    C_CreateObject: TfC_CreateObject;
    C_CopyObject: TfC_CopyObject;
    C_DestroyObject: TfC_DestroyObject;
    C_GetObjectSize: TfC_GetObjectSize;
    C_GetAttributeValue: TfC_GetAttributeValue;
    C_SetAttributeValue: TfC_SetAttributeValue;
    C_FindObjectsInit: TfC_FindObjectsInit;
    C_FindObjects: TfC_FindObjects;
    C_FindObjectsFinal: TfC_FindObjectsFinal;
    C_EncryptInit: TfC_EncryptInit;
    C_Encrypt: TfC_Encrypt;
    C_EncryptUpdate: TfC_EncryptUpdate;
    C_EncryptFinal: TfC_EncryptFinal;
    C_DecryptInit: TfC_DecryptInit;
    C_Decrypt: TfC_Decrypt;
    C_DecryptUpdate: TfC_DecryptUpdate;
    C_DecryptFinal: TfC_DecryptFinal;
    C_DigestInit: TfC_DigestInit;
    C_Digest: TfC_Digest;
    C_DigestUpdate: TfC_DigestUpdate;
    C_DigestKey: TfC_DigestKey;
    C_DigestFinal: TfC_DigestFinal;
    C_SignInit: TfC_SignInit;
    C_Sign: TfC_Sign;
    C_SignUpdate: TfC_SignUpdate;
    C_SignFinal: TfC_SignFinal;
    C_SignRecoverInit: TfC_SignRecoverInit;
    C_SignRecover: TfC_SignRecover;
    C_VerifyInit: TfC_VerifyInit;
    C_Verify: TfC_Verify;
    C_VerifyUpdate: TfC_VerifyUpdate;
    C_VerifyFinal: TfC_VerifyFinal;
    C_VerifyRecoverInit: TfC_VerifyRecoverInit;
    C_VerifyRecover: TfC_VerifyRecover;
    C_DigestEncryptUpdate: TfC_DigestEncryptUpdate;
    C_DecryptDigestUpdate: TfC_DecryptDigestUpdate;
    C_SignEncryptUpdate: TfC_SignEncryptUpdate;
    C_DecryptVerifyUpdate: TfC_DecryptVerifyUpdate;
    C_GenerateKey: TfC_GenerateKey;
    C_GenerateKeyPair: TfC_GenerateKeyPair;
    C_WrapKey: TfC_WrapKey;
    C_UnwrapKey: TfC_UnwrapKey;
    C_DeriveKey: TfC_DeriveKey;
    C_SeedRandom: TfC_SeedRandom;
    C_GenerateRandom: TfC_GenerateRandom;
    C_GetFunctionStatus: TfC_GetFunctionStatus;
    C_CancelFunction: TfC_CancelFunction;
    C_WaitForSlotEvent: TfC_WaitForSlotEvent;
  end;                                  { CK_FUNCTION_LIST }

  // CK_CREATEMUTEX IS AN APPLICATION CALLBACK FOR CREATING A mutex object }
  CK_CREATEMUTEX = function(ppMutex: CK_VOID_PTR): CK_RV;

  {+// CK_DESTROYMUTEX is an application callback for destroying a mutex object }
  CK_DESTROYMUTEX = function(ppMutex: CK_VOID_PTR): CK_RV;

  {+// CK_LOCKMUTEX is an application callback for locking a mutex*/ }
  CK_LOCKMUTEX = function(ppMutex: CK_VOID_PTR): CK_RV;

  {+// CK_UNLOCKMUTEX is an application callback for unlocking a mutex }
  CK_UNLOCKMUTEX = function(ppMutex: CK_VOID_PTR): CK_RV;

  {+// CK_C_INITIALIZE_ARGS provides the optional arguments to C_Initialize }
  CK_C_INITIALIZE_ARGS = record
    CreateMutex: CK_CREATEMUTEX;
    DestroyMutex: CK_DESTROYMUTEX;
    LockMutex: CK_LOCKMUTEX;
    UnlockMutex: CK_UNLOCKMUTEX;
    flags: CK_FLAGS;
    pReserved: CK_VOID_PTR;
  end {CK_C_INITIALIZE_ARGS};

  {+// flags: bit flags that provide capabilities of the slot Bit Flag Mask Meaning }
const
  CKF_LIBRARY_CANT_CREATE_OS_THREADS = $00000001;
  CKF_OS_LOCKING_OK = $00000002;

type
  CK_C_INITIALIZE_ARGS_PTR = ^CK_C_INITIALIZE_ARGS;

  {+// additional flags for parameters to functions*/ }

  {+// CKF_DONT_BLOCK is for the function C_WaitForSlotEvent*/ }
const
  CKF_DONT_BLOCK = 1;

  {+// CK_RSA_PKCS_OAEP_MGF_TYPE is new for v2.10. }
  {-* CK_RSA_PKCS_OAEP_MGF_TYPE is used to indicate the Message }
  {-* Generation Function (MGF) applied to a message block when }
  {* formatting a message block for the PKCS #1 OAEP encryption }
  {=* scheme. }
type
  CK_RSA_PKCS_MGF_TYPE = CK_ULONG;

  CK_RSA_PKCS_MGF_TYPE_PTR = ^CK_RSA_PKCS_MGF_TYPE;

  {+// The following MGFs are defined*/ }
  {+// CKG_MGF1_SHA256, CKG_MGF1_SHA384, and CKG_MGF1_SHA512
     * are new for v2.20 */ }
const
  CKG_MGF1_SHA1 = $00000001;
  CKG_MGF1_SHA256 = $00000002;
  CKG_MGF1_SHA384 = $00000003;
  CKG_MGF1_SHA512 = $00000004;

  {+// CK_RSA_PKCS_OAEP_SOURCE_TYPE is new for v2.10. }
  {-* CK_RSA_PKCS_OAEP_SOURCE_TYPE is used to indicate the source }
  {-* of the encoding parameter when formatting a message block }
  {* for the PKCS #1 OAEP encryption scheme.*/ }
type
  CK_RSA_PKCS_OAEP_SOURCE_TYPE = CK_ULONG;
  CK_RSA_PKCS_OAEP_SOURCE_TYPE_PTR = ^CK_RSA_PKCS_OAEP_SOURCE_TYPE;

  {=/* The following encoding parameter sources are defined }
const
  CKZ_DATA_SPECIFIED = $00000001;

  {+// CK_RSA_PKCS_OAEP_PARAMS is new for v2.10. }
  {-* CK_RSA_PKCS_OAEP_PARAMS provides the parameters to the }
  {=* CKM_RSA_PKCS_OAEP mechanism. }
type
  CK_RSA_PKCS_OAEP_PARAMS = record
    hashAlg: CK_MECHANISM_TYPE;
    mgf: CK_RSA_PKCS_MGF_TYPE;
    source: CK_RSA_PKCS_OAEP_SOURCE_TYPE;
    pSourceData: CK_VOID_PTR;
    ulSourceDataLen: CK_ULONG;
  end {CK_RSA_PKCS_OAEP_PARAMS};
  CK_RSA_PKCS_OAEP_PARAMS_PTR = ^CK_RSA_PKCS_OAEP_PARAMS;

  {+// CK_RSA_PKCS_PSS_PARAMS is new for v2.11. }
  {-* CK_RSA_PKCS_PSS_PARAMS provides the parameters to the }
  {=* CKM_RSA_PKCS_PSS mechanism(s). }
  CK_RSA_PKCS_PSS_PARAMS = record
    hashAlg: CK_MECHANISM_TYPE;
    mgf: CK_RSA_PKCS_MGF_TYPE;
    sLen: CK_ULONG;
  end {CK_RSA_PKCS_PSS_PARAMS};
  CK_RSA_PKCS_PSS_PARAMS_PTR = ^CK_RSA_PKCS_PSS_PARAMS;

  {+// CK_EC_KDF_TYPE is new for v2.11.*/ }
  CK_EC_KDF_TYPE = CK_ULONG;

  {+// The following EC Key Derivation Functions are defined*/ }
const
  CKD_NULL = $00000001;
  CKD_SHA1_KDF = $00000002;

  {+// CK_ECDH1_DERIVE_PARAMS is new for v2.11. }
  {-* CK_ECDH1_DERIVE_PARAMS provides the parameters to the }
  {-* CKM_ECDH1_DERIVE and CKM_ECDH1_COFACTOR_DERIVE mechanisms, }
  {-* where each party contributes one key pair. }
  {= }
type
  CK_ECDH1_DERIVE_PARAMS = record
    kdf: CK_EC_KDF_TYPE;
    ulSharedDataLen: CK_ULONG;
    pSharedData: CK_BYTE_PTR;
    ulPublicDataLen: CK_ULONG;
    pPublicData: CK_BYTE_PTR;
  end {CK_ECDH1_DERIVE_PARAMS};
  CK_ECDH1_DERIVE_PARAMS_PTR = ^CK_ECDH1_DERIVE_PARAMS;

  {+// CK_ECDH2_DERIVE_PARAMS is new for v2.11. }
  {-* CK_ECDH2_DERIVE_PARAMS provides the parameters to the }
  {=* CKM_ECMQV_DERIVE mechanism, where each party contributes two key pairs. }
  CK_ECDH2_DERIVE_PARAMS = record
    kdf: CK_EC_KDF_TYPE;
    ulSharedDataLen: CK_ULONG;
    pSharedData: CK_BYTE_PTR;
    ulPublicDataLen: CK_ULONG;
    pPublicData: CK_BYTE_PTR;
    ulPrivateDataLen: CK_ULONG;
    hPrivateData: CK_OBJECT_HANDLE;
    ulPublicDataLen2: CK_ULONG;
    pPublicData2: CK_BYTE_PTR;
  end {CK_ECDH2_DERIVE_PARAMS};
  CK_ECDH2_DERIVE_PARAMS_PTR = ^CK_ECDH2_DERIVE_PARAMS;

  {+// Typedefs and defines for the CKM_X9_42_DH_KEY_PAIR_GEN and the }
  {* CKM_X9_42_DH_PARAMETER_GEN mechanisms (new for PKCS #11 v2.11)*/ }
  CK_X9_42_DH_KDF_TYPE = CK_ULONG;
  CK_X9_42_DH_KDF_TYPE_PTR = ^CK_X9_42_DH_KDF_TYPE;

  {=/* The following X9.42 DH key derivation functions are defined: }
const
  // CKD_NULL = $00000001;

  CKD_SHA1_KDF_ASN1 = $00000003;
  CKD_SHA1_KDF_CONCATENATE = $00000004;

  {+// CK_X9_42_DH1_DERIVE_PARAMS is new for v2.11. }
  {-* CK_X9_42_DH1_DERIVE_PARAMS provides the parameters to the }
  {-* CKM_X9_42_DH_DERIVE key derivation mechanism, where each party }
  {=* contributes one key pair }
type
  CK_X9_42_DH1_DERIVE_PARAMS = record
    kdf: CK_X9_42_DH_KDF_TYPE;
    ulOtherInfoLen: CK_ULONG;
    pOtherInfo: CK_BYTE_PTR;
    ulPublicDataLen: CK_ULONG;
    pPublicData: CK_BYTE_PTR;
  end {CK_X9_42_DH1_DERIVE_PARAMS};
  CK_X9_42_DH1_DERIVE_PARAMS_PTR = ^CK_X9_42_DH1_DERIVE_PARAMS;

  // CK_X9_42_DH2_DERIVE_PARAMS IS NEW FOR V2.11.;
  {-* CK_X9_42_DH2_DERIVE_PARAMS provides the parameters to the }
  {-* CKM_X9_42_DH_HYBRID_DERIVE and CKM_X9_42_MQV_DERIVE key derivation }
  {=* mechanisms, where each party contributes two key pairs }
  CK_X9_42_DH2_DERIVE_PARAMS = record
    kdf: CK_X9_42_DH_KDF_TYPE;
    ulOtherInfoLen: CK_ULONG;
    pOtherInfo: CK_BYTE_PTR;
    ulPublicDataLen: CK_ULONG;
    pPublicData: CK_BYTE_PTR;
    ulPrivateDataLen: CK_ULONG;
    hPrivateData: CK_OBJECT_HANDLE;
    ulPublicDataLen2: CK_ULONG;
    pPublicData2: CK_BYTE_PTR;
  end {CK_X9_42_DH1_DERIVE_PARAMS};
  CK_X9_42_DH2_DERIVE_PARAMS_PTR = ^CK_X9_42_DH2_DERIVE_PARAMS;

  {+// CK_KEA_DERIVE_PARAMS provides the parameters to the }
  {=* CKM_KEA_DERIVE mechanism }
  {+// CK_KEA_DERIVE_PARAMS is new for v2.0*/ }
  CK_KEA_DERIVE_PARAMS = record
    isSender: CK_BBOOL;
    ulRandomLen: CK_ULONG;
    pRandomA: CK_BYTE_PTR;
    pRandomB: CK_BYTE_PTR;
    ulPublicDataLen: CK_ULONG;
    pPublicData: CK_BYTE_PTR;
  end {CK_KEA_DERIVE_PARAMS};
  CK_KEA_DERIVE_PARAMS_PTR = ^CK_KEA_DERIVE_PARAMS;

  {+// CK_RC2_PARAMS provides the parameters to the CKM_RC2_ECB and }
  {-* CKM_RC2_MAC mechanisms. An instance of CK_RC2_PARAMS just }
  {=* holds the effective keysize }
  CK_RC2_PARAMS = CK_ULONG;

  CK_RC2_PARAMS_PTR = ^CK_RC2_PARAMS;

  {+// CK_RC2_CBC_PARAMS provides the parameters to the CKM_RC2_CBC }
  {=* mechanism }
  CK_RC2_CBC_PARAMS = record
    {+// ulEffectiveBits was changed from CK_USHORT to CK_ULONG for v2.0 }
    ulEffectiveBits: CK_ULONG;          {= effective bits (1-1024) }
    iv: array[0..8 - 1] of CK_BYTE;     {= IV for CBC mode }
  end {CK_RC2_CBC_PARAMS};
  CK_RC2_CBC_PARAMS_PTR = ^CK_RC2_CBC_PARAMS;

  {+// CK_RC2_MAC_GENERAL_PARAMS provides the parameters for the }
  {=* CKM_RC2_MAC_GENERAL mechanism }
  {+// CK_RC2_MAC_GENERAL_PARAMS is new for v2.0*/ }
  CK_RC2_MAC_GENERAL_PARAMS = record
    ulEffectiveBits: CK_ULONG;          {= effective bits (1-1024) }
    ulMacLength: CK_ULONG;              {= Length of MAC in bytes }
  end {CK_RC2_MAC_GENERAL_PARAMS};
  CK_RC2_MAC_GENERAL_PARAMS_PTR = ^CK_RC2_MAC_GENERAL_PARAMS;

  {+// CK_RC5_PARAMS provides the parameters to the CKM_RC5_ECB and }
  {=* CKM_RC5_MAC mechanisms }
  {+// CK_RC5_PARAMS is new for v2.0*/ }
  CK_RC5_PARAMS = record
    ulWordsize: CK_ULONG;               {= wordsize in bits }
    ulRounds: CK_ULONG;                 {= number of rounds }
  end {CK_RC5_PARAMS};
  CK_RC5_PARAMS_PTR = ^CK_RC5_PARAMS;

  {+// CK_RC5_CBC_PARAMS provides the parameters to the CKM_RC5_CBC }
  {=* mechanism }
  {+// CK_RC5_CBC_PARAMS is new for v2.0*/ }
  CK_RC5_CBC_PARAMS = record
    ulWordsize: CK_ULONG;               {= wordsize in bits }
    ulRounds: CK_ULONG;                 {= number of rounds }
    pIv: CK_BYTE_PTR;                   {= pointer to IV }
    ulIvLen: CK_ULONG;                  {= length of IV in bytes }
  end {CK_RC5_CBC_PARAMS};
  CK_RC5_CBC_PARAMS_PTR = ^CK_RC5_CBC_PARAMS;

  {+// CK_RC5_MAC_GENERAL_PARAMS provides the parameters for the }
  {=* CKM_RC5_MAC_GENERAL mechanism }
  {+// CK_RC5_MAC_GENERAL_PARAMS is new for v2.0*/ }
  CK_RC5_MAC_GENERAL_PARAMS = record
    ulWordsize: CK_ULONG;               {= wordsize in bits }
    ulRounds: CK_ULONG;                 {= number of rounds }
    ulMacLength: CK_ULONG;              {= Length of MAC in bytes }
  end {CK_RC5_MAC_GENERAL_PARAMS};
  CK_RC5_MAC_GENERAL_PARAMS_PTR = ^CK_RC5_MAC_GENERAL_PARAMS;

  {+// CK_MAC_GENERAL_PARAMS provides the parameters to most block }
  {-* ciphers' MAC_GENERAL mechanisms. Its value is the length of }
  {=* the MAC }
  {+// CK_MAC_GENERAL_PARAMS is new for v2.0*/ }
  CK_MAC_GENERAL_PARAMS = CK_ULONG;
  CK_MAC_GENERAL_PARAMS_PTR = ^CK_MAC_GENERAL_PARAMS;

  {+// CK_DES/AES_ECB/CBC_ENCRYPT_DATA_PARAMS are new for v2.20 */ }
  CK_DES_CBC_ENCRYPT_DATA_PARAMS = record
    iv: array[0..8-1] of CK_BYTE;
    pData: CK_BYTE_PTR;
    length: CK_ULONG;
  end; //CK_DES_CBC_ENCRYPT_DATA_PARAMS;
  CK_DES_CBC_ENCRYPT_DATA_PARAMS_PTR = ^CK_DES_CBC_ENCRYPT_DATA_PARAMS;

  CK_AES_CBC_ENCRYPT_DATA_PARAMS = record
    iv: array[0..16-1] of CK_BYTE;
    pData: CK_BYTE_PTR;
    length: CK_ULONG;
  end; // CK_AES_CBC_ENCRYPT_DATA_PARAMS
  CK_AES_CBC_ENCRYPT_DATA_PARAMS_PTR = ^CK_AES_CBC_ENCRYPT_DATA_PARAMS;

  {+// CK_SKIPJACK_PRIVATE_WRAP_PARAMS provides the parameters to the }
  {=* CKM_SKIPJACK_PRIVATE_WRAP mechanism }
  {+// CK_SKIPJACK_PRIVATE_WRAP_PARAMS is new for v2.0*/ }
  CK_SKIPJACK_PRIVATE_WRAP_PARAMS = record
    ulPasswordLen: CK_ULONG;
    pPassword: CK_BYTE_PTR;
    ulPublicDataLen: CK_ULONG;
    pPublicData: CK_BYTE_PTR;
    ulPAndGLen: CK_ULONG;
    ulQLen: CK_ULONG;
    ulRandomLen: CK_ULONG;
    pRandomA: CK_BYTE_PTR;
    pPrimeP: CK_BYTE_PTR;
    pBaseG: CK_BYTE_PTR;
    pSubprimeQ: CK_BYTE_PTR;
  end {CK_SKIPJACK_PRIVATE_WRAP_PARAMS};
  CK_SKIPJACK_PRIVATE_WRAP_PTR = ^CK_SKIPJACK_PRIVATE_WRAP_PARAMS;

  {+// CK_SKIPJACK_RELAYX_PARAMS provides the parameters to the }
  {=* CKM_SKIPJACK_RELAYX mechanism }
  {+// CK_SKIPJACK_RELAYX_PARAMS is new for v2.0*/ }
  CK_SKIPJACK_RELAYX_PARAMS = record
    ulOldWrappedXLen: CK_ULONG;
    pOldWrappedX: CK_BYTE_PTR;
    ulOldPasswordLen: CK_ULONG;
    pOldPassword: CK_BYTE_PTR;
    ulOldPublicDataLen: CK_ULONG;
    pOldPublicData: CK_BYTE_PTR;
    ulOldRandomLen: CK_ULONG;
    pOldRandomA: CK_BYTE_PTR;
    ulNewPasswordLen: CK_ULONG;
    pNewPassword: CK_BYTE_PTR;
    ulNewPublicDataLen: CK_ULONG;
    pNewPublicData: CK_BYTE_PTR;
    ulNewRandomLen: CK_ULONG;
    pNewRandomA: CK_BYTE_PTR;
  end {CK_SKIPJACK_RELAYX_PARAMS};
  CK_SKIPJACK_RELAYX_PARAMS_PTR = ^CK_SKIPJACK_RELAYX_PARAMS;

  CK_PBE_PARAMS = record
    pInitVector: CK_BYTE_PTR;
    pPassword: CK_UTF8CHAR_PTR;
    ulPasswordLen: CK_ULONG;
    pSalt: CK_BYTE_PTR;
    ulSaltLen: CK_ULONG;
    ulIteration: CK_ULONG;
  end {CK_PBE_PARAMS};
  CK_PBE_PARAMS_PTR = ^CK_PBE_PARAMS;

  {+// CK_KEY_WRAP_SET_OAEP_PARAMS provides the parameters to the }
  {=* CKM_KEY_WRAP_SET_OAEP mechanism }
  {+// CK_KEY_WRAP_SET_OAEP_PARAMS is new for v2.0*/ }
  CK_KEY_WRAP_SET_OAEP_PARAMS = record
    bBC: CK_BYTE;                       {= block contents byte }
    pX: CK_BYTE_PTR;                    {= extra data }
    ulXLen: CK_ULONG;                   {= length of extra data in bytes }
  end {CK_KEY_WRAP_SET_OAEP_PARAMS};
  CK_KEY_WRAP_SET_OAEP_PARAMS_PTR = ^CK_KEY_WRAP_SET_OAEP_PARAMS;

  CK_SSL3_RANDOM_DATA = record
    pClientRandom: CK_BYTE_PTR;
    ulClientRandomLen: CK_ULONG;
    pServerRandom: CK_BYTE_PTR;
    ulServerRandomLen: CK_ULONG;
  end {CK_SSL3_RANDOM_DATA};

  CK_SSL3_MASTER_KEY_DERIVE_PARAMS = record
    RandomInfo: CK_SSL3_RANDOM_DATA;
    pVersion: CK_VERSION_PTR;
  end {CK_SSL3_MASTER_KEY_DERIVE_PARAMS};
  CK_SSL3_MASTER_KEY_DERIVE_PARAMS_PTR = ^CK_SSL3_MASTER_KEY_DERIVE_PARAMS;

  CK_SSL3_KEY_MAT_OUT = record
    hClientMacSecret: CK_OBJECT_HANDLE;
    hServerMacSecret: CK_OBJECT_HANDLE;
    hClientKey: CK_OBJECT_HANDLE;
    hServerKey: CK_OBJECT_HANDLE;
    pIVClient: CK_BYTE_PTR;
    pIVServer: CK_BYTE_PTR;
  end {CK_SSL3_MASTER_KEY_DERIVE_PARAMS};
  CK_SSL3_KEY_MAT_OUT_PTR = ^CK_SSL3_KEY_MAT_OUT;

  CK_SSL3_KEY_MAT_PARAMS = record
    ulMacSizeInBits: CK_ULONG;
    ulKeySizeInBits: CK_ULONG;
    ulIVSizeInBits: CK_ULONG;
    bIsExport: CK_BBOOL;
    RandomInfo: CK_SSL3_RANDOM_DATA;
    pReturnedKeyMaterial: CK_SSL3_KEY_MAT_OUT_PTR;
  end {CK_SSL3_KEY_MAT_PARAMS};
  CK_SSL3_KEY_MAT_PARAMS_PTR = ^CK_SSL3_KEY_MAT_PARAMS;

  CK_KEY_DERIVATION_STRING_DATA = record
    pData: CK_BYTE_PTR;
    ulLen: CK_ULONG;
  end {CK_KEY_DERIVATION_STRING_DATA};
  CK_KEY_DERIVATION_STRING_DATA_PTR = ^CK_KEY_DERIVATION_STRING_DATA;

  {+// The CK_EXTRACT_PARAMS is used for the }
  {-* CKM_EXTRACT_KEY_FROM_KEY mechanism. It specifies which bit }
  {-* of the base key should be used as the first bit of the }
  {=* derived key }
  {+// CK_EXTRACT_PARAMS is new for v2.0*/ }
  CK_EXTRACT_PARAMS = CK_ULONG;
  CK_EXTRACT_PARAMS_PTR = ^CK_EXTRACT_PARAMS;

  {+// CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE is new for v2.10. }
  {-* CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE is used to }
  {-* indicate the Pseudo-Random Function (PRF) used to generate }
  {* key bits using PKCS #5 PBKDF2.*/ }

  CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE = CK_ULONG;
  CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE_PTR = ^CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE;

  { /* The following PRFs are defined in PKCS #5 v2.0.*/ }
const
  CKP_PKCS5_PBKD2_HMAC_SHA1 = $00000001;

  {-/* CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE is new for v2.10. }
  {-* CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE is used to indicate the }
  {* source of the salt value when deriving a key using PKCS #5 }
  {=* PBKDF2. }
type
  CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE = CK_ULONG;
  CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE_PTR = ^CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE;

  { /* The following salt value sources are defined in PKCS #5 v2.0.*/ }
const
  CKZ_SALT_SPECIFIED = $00000001;

  {+// CK_PKCS5_PBKD2_PARAMS is new for v2.10. }
  {-* CK_PKCS5_PBKD2_PARAMS is a structure that provides the }
  {=* parameters to the CKM_PKCS5_PBKD2 mechanism. }
type
  CK_PKCS5_PBKD2_PARAMS = record
    saltSource: CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE;
    pSaltSourceData: CK_VOID_PTR;
    ulSaltSourceDataLen: CK_ULONG;
    iterations: CK_ULONG;
    prf: CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE;
    pPrfData: CK_VOID_PTR;
    ulPrfDataLen: CK_ULONG;
    pPassword: CK_UTF8CHAR_PTR;
    ulPasswordLen: CK_ULONG_PTR;
  end {CK_PKCS5_PBKD2_PARAMS};
  CK_PKCS5_PBKD2_PARAMS_PTR = ^CK_PKCS5_PBKD2_PARAMS;

{$ENDIF}

implementation

end.

